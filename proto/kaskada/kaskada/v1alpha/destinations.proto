syntax = "proto3";
package kaskada.kaskada.v1alpha;

message ObjectStoreDestination {
  FileFormat format = 1;

  // The uri of where to push output to.
  //
  // examples:
  // s3://my-bucket/path/to/results/
  // file:///local/path/to/results/
  string output_prefix_uri = 2;

  enum FileFormat {
    FILE_FORMAT_UNSPECIFIED = 0;

    // Format result files as Parquet.
    FILE_FORMAT_PARQUET = 1;

    // Format result files as CSV.
    FILE_FORMAT_CSV = 2;
  }
}

message RedisDestination {
  // The hostname of the Redis instance.
  string host_name = 1;

  // The port of the Redis instance.
  int32 port = 2;

  // When `true`, TLS will be used to connect to Redis.
  bool use_tls = 3;

  // The Redis database number 0 to 15.
  int32 database_number = 4;

  // The password to connect to the Redis instance
  string password = 5;

  // An X.509 certificate to use for authenticating the server
  // to connected clients, masters or cluster peers.
  // The string should be PEM formatted.
  string tls_cert = 6;

  // An X.509 private key to use for authenticating the server
  // to connected clients, masters or cluster peers.
  // The string should be PEM formatted.
  string tls_key = 7;

  // A PEM encoded CA's certificate.
  string tls_ca_cert = 8;

  // InsecureSkipVerify controls whether a client verifies the
  // server's certificate chain and host name.
  // If this field is true, TLS accepts any certificate
  // presented by the server and any host name in that certificate.
  // In this mode, TLS is susceptible to man-in-the-middle attacks.
  // This should be used only for testing.
  bool insecure_skip_verify = 9;
}
