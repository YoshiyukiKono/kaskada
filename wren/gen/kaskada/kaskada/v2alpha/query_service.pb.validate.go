// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: kaskada/kaskada/v2alpha/query_service.proto

package kaskadav2alpha

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on LatestDataToken with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LatestDataToken) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LatestDataToken with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LatestDataTokenMultiError, or nil if none found.
func (m *LatestDataToken) ValidateAll() error {
	return m.validate(true)
}

func (m *LatestDataToken) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DataTokenId

	if len(errors) > 0 {
		return LatestDataTokenMultiError(errors)
	}

	return nil
}

// LatestDataTokenMultiError is an error wrapping multiple validation errors
// returned by LatestDataToken.ValidateAll() if the designated constraints
// aren't met.
type LatestDataTokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LatestDataTokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LatestDataTokenMultiError) AllErrors() []error { return m }

// LatestDataTokenValidationError is the validation error returned by
// LatestDataToken.Validate if the designated constraints aren't met.
type LatestDataTokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LatestDataTokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LatestDataTokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LatestDataTokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LatestDataTokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LatestDataTokenValidationError) ErrorName() string { return "LatestDataTokenValidationError" }

// Error satisfies the builtin error interface
func (e LatestDataTokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLatestDataToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LatestDataTokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LatestDataTokenValidationError{}

// Validate checks the field values on SpecificDataToken with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SpecificDataToken) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpecificDataToken with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpecificDataTokenMultiError, or nil if none found.
func (m *SpecificDataToken) ValidateAll() error {
	return m.validate(true)
}

func (m *SpecificDataToken) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDataTokenId()) < 1 {
		err := SpecificDataTokenValidationError{
			field:  "DataTokenId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SpecificDataTokenMultiError(errors)
	}

	return nil
}

// SpecificDataTokenMultiError is an error wrapping multiple validation errors
// returned by SpecificDataToken.ValidateAll() if the designated constraints
// aren't met.
type SpecificDataTokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpecificDataTokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpecificDataTokenMultiError) AllErrors() []error { return m }

// SpecificDataTokenValidationError is the validation error returned by
// SpecificDataToken.Validate if the designated constraints aren't met.
type SpecificDataTokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpecificDataTokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpecificDataTokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpecificDataTokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpecificDataTokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpecificDataTokenValidationError) ErrorName() string {
	return "SpecificDataTokenValidationError"
}

// Error satisfies the builtin error interface
func (e SpecificDataTokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecificDataToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpecificDataTokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpecificDataTokenValidationError{}

// Validate checks the field values on DataToken with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataToken) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataToken with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DataTokenMultiError, or nil
// if none found.
func (m *DataToken) ValidateAll() error {
	return m.validate(true)
}

func (m *DataToken) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.DataToken.(type) {

	case *DataToken_LatestDataToken:

		if all {
			switch v := interface{}(m.GetLatestDataToken()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DataTokenValidationError{
						field:  "LatestDataToken",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DataTokenValidationError{
						field:  "LatestDataToken",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLatestDataToken()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DataTokenValidationError{
					field:  "LatestDataToken",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DataToken_SpecificDataToken:

		if all {
			switch v := interface{}(m.GetSpecificDataToken()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DataTokenValidationError{
						field:  "SpecificDataToken",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DataTokenValidationError{
						field:  "SpecificDataToken",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSpecificDataToken()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DataTokenValidationError{
					field:  "SpecificDataToken",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		err := DataTokenValidationError{
			field:  "DataToken",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return DataTokenMultiError(errors)
	}

	return nil
}

// DataTokenMultiError is an error wrapping multiple validation errors returned
// by DataToken.ValidateAll() if the designated constraints aren't met.
type DataTokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataTokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataTokenMultiError) AllErrors() []error { return m }

// DataTokenValidationError is the validation error returned by
// DataToken.Validate if the designated constraints aren't met.
type DataTokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataTokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataTokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataTokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataTokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataTokenValidationError) ErrorName() string { return "DataTokenValidationError" }

// Error satisfies the builtin error interface
func (e DataTokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataTokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataTokenValidationError{}

// Validate checks the field values on QueryView with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryView) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryView with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryViewMultiError, or nil
// if none found.
func (m *QueryView) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryView) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetViewName()) < 1 {
		err := QueryViewValidationError{
			field:  "ViewName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetExpression()) < 1 {
		err := QueryViewValidationError{
			field:  "Expression",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return QueryViewMultiError(errors)
	}

	return nil
}

// QueryViewMultiError is an error wrapping multiple validation errors returned
// by QueryView.ValidateAll() if the designated constraints aren't met.
type QueryViewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryViewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryViewMultiError) AllErrors() []error { return m }

// QueryViewValidationError is the validation error returned by
// QueryView.Validate if the designated constraints aren't met.
type QueryViewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryViewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryViewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryViewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryViewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryViewValidationError) ErrorName() string { return "QueryViewValidationError" }

// Error satisfies the builtin error interface
func (e QueryViewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryView.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryViewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryViewValidationError{}

// Validate checks the field values on DestinationRedisAI with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DestinationRedisAI) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DestinationRedisAI with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DestinationRedisAIMultiError, or nil if none found.
func (m *DestinationRedisAI) ValidateAll() error {
	return m.validate(true)
}

func (m *DestinationRedisAI) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetDb(); val < 0 || val > 15 {
		err := DestinationRedisAIValidationError{
			field:  "Db",
			reason: "value must be inside range [0, 15]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetHost()) < 1 {
		err := DestinationRedisAIValidationError{
			field:  "Host",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetPort(); val <= 0 || val > 65535 {
		err := DestinationRedisAIValidationError{
			field:  "Port",
			reason: "value must be inside range (0, 65535]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DestinationRedisAIMultiError(errors)
	}

	return nil
}

// DestinationRedisAIMultiError is an error wrapping multiple validation errors
// returned by DestinationRedisAI.ValidateAll() if the designated constraints
// aren't met.
type DestinationRedisAIMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DestinationRedisAIMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DestinationRedisAIMultiError) AllErrors() []error { return m }

// DestinationRedisAIValidationError is the validation error returned by
// DestinationRedisAI.Validate if the designated constraints aren't met.
type DestinationRedisAIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DestinationRedisAIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DestinationRedisAIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DestinationRedisAIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DestinationRedisAIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DestinationRedisAIValidationError) ErrorName() string {
	return "DestinationRedisAIValidationError"
}

// Error satisfies the builtin error interface
func (e DestinationRedisAIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDestinationRedisAI.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DestinationRedisAIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DestinationRedisAIValidationError{}

// Validate checks the field values on Destination with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Destination) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Destination with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DestinationMultiError, or
// nil if none found.
func (m *Destination) ValidateAll() error {
	return m.validate(true)
}

func (m *Destination) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAsFiles()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DestinationValidationError{
					field:  "AsFiles",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DestinationValidationError{
					field:  "AsFiles",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAsFiles()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DestinationValidationError{
				field:  "AsFiles",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRedisAI()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DestinationValidationError{
					field:  "RedisAI",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DestinationValidationError{
					field:  "RedisAI",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRedisAI()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DestinationValidationError{
				field:  "RedisAI",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DestinationMultiError(errors)
	}

	return nil
}

// DestinationMultiError is an error wrapping multiple validation errors
// returned by Destination.ValidateAll() if the designated constraints aren't met.
type DestinationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DestinationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DestinationMultiError) AllErrors() []error { return m }

// DestinationValidationError is the validation error returned by
// Destination.Validate if the designated constraints aren't met.
type DestinationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DestinationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DestinationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DestinationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DestinationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DestinationValidationError) ErrorName() string { return "DestinationValidationError" }

// Error satisfies the builtin error interface
func (e DestinationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDestination.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DestinationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DestinationValidationError{}

// Validate checks the field values on AllResults with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AllResults) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AllResults with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AllResultsMultiError, or
// nil if none found.
func (m *AllResults) ValidateAll() error {
	return m.validate(true)
}

func (m *AllResults) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetChangedSinceTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AllResultsValidationError{
					field:  "ChangedSinceTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AllResultsValidationError{
					field:  "ChangedSinceTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChangedSinceTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AllResultsValidationError{
				field:  "ChangedSinceTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AllResultsMultiError(errors)
	}

	return nil
}

// AllResultsMultiError is an error wrapping multiple validation errors
// returned by AllResults.ValidateAll() if the designated constraints aren't met.
type AllResultsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AllResultsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AllResultsMultiError) AllErrors() []error { return m }

// AllResultsValidationError is the validation error returned by
// AllResults.Validate if the designated constraints aren't met.
type AllResultsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AllResultsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AllResultsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AllResultsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AllResultsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AllResultsValidationError) ErrorName() string { return "AllResultsValidationError" }

// Error satisfies the builtin error interface
func (e AllResultsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAllResults.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AllResultsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AllResultsValidationError{}

// Validate checks the field values on FinalResults with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FinalResults) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalResults with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FinalResultsMultiError, or
// nil if none found.
func (m *FinalResults) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalResults) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetChangedSinceTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalResultsValidationError{
					field:  "ChangedSinceTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalResultsValidationError{
					field:  "ChangedSinceTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChangedSinceTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalResultsValidationError{
				field:  "ChangedSinceTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinalResultTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalResultsValidationError{
					field:  "FinalResultTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalResultsValidationError{
					field:  "FinalResultTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalResultTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalResultsValidationError{
				field:  "FinalResultTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FinalResultsMultiError(errors)
	}

	return nil
}

// FinalResultsMultiError is an error wrapping multiple validation errors
// returned by FinalResults.ValidateAll() if the designated constraints aren't met.
type FinalResultsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalResultsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalResultsMultiError) AllErrors() []error { return m }

// FinalResultsValidationError is the validation error returned by
// FinalResults.Validate if the designated constraints aren't met.
type FinalResultsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalResultsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalResultsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalResultsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalResultsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalResultsValidationError) ErrorName() string { return "FinalResultsValidationError" }

// Error satisfies the builtin error interface
func (e FinalResultsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalResults.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalResultsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalResultsValidationError{}

// Validate checks the field values on FinalResultsAtTime with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalResultsAtTime) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalResultsAtTime with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinalResultsAtTimeMultiError, or nil if none found.
func (m *FinalResultsAtTime) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalResultsAtTime) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetChangedSinceTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalResultsAtTimeValidationError{
					field:  "ChangedSinceTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalResultsAtTimeValidationError{
					field:  "ChangedSinceTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChangedSinceTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalResultsAtTimeValidationError{
				field:  "ChangedSinceTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinalResultTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalResultsAtTimeValidationError{
					field:  "FinalResultTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalResultsAtTimeValidationError{
					field:  "FinalResultTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalResultTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalResultsAtTimeValidationError{
				field:  "FinalResultTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FinalResultsAtTimeMultiError(errors)
	}

	return nil
}

// FinalResultsAtTimeMultiError is an error wrapping multiple validation errors
// returned by FinalResultsAtTime.ValidateAll() if the designated constraints
// aren't met.
type FinalResultsAtTimeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalResultsAtTimeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalResultsAtTimeMultiError) AllErrors() []error { return m }

// FinalResultsAtTimeValidationError is the validation error returned by
// FinalResultsAtTime.Validate if the designated constraints aren't met.
type FinalResultsAtTimeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalResultsAtTimeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalResultsAtTimeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalResultsAtTimeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalResultsAtTimeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalResultsAtTimeValidationError) ErrorName() string {
	return "FinalResultsAtTimeValidationError"
}

// Error satisfies the builtin error interface
func (e FinalResultsAtTimeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalResultsAtTime.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalResultsAtTimeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalResultsAtTimeValidationError{}

// Validate checks the field values on ResultBehavior with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResultBehavior) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResultBehavior with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResultBehaviorMultiError,
// or nil if none found.
func (m *ResultBehavior) ValidateAll() error {
	return m.validate(true)
}

func (m *ResultBehavior) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.ResultBehavior.(type) {

	case *ResultBehavior_AllResults:

		if all {
			switch v := interface{}(m.GetAllResults()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResultBehaviorValidationError{
						field:  "AllResults",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResultBehaviorValidationError{
						field:  "AllResults",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAllResults()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResultBehaviorValidationError{
					field:  "AllResults",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResultBehavior_FinalResults:

		if all {
			switch v := interface{}(m.GetFinalResults()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResultBehaviorValidationError{
						field:  "FinalResults",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResultBehaviorValidationError{
						field:  "FinalResults",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFinalResults()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResultBehaviorValidationError{
					field:  "FinalResults",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResultBehavior_FinalResultsAtTime:

		if all {
			switch v := interface{}(m.GetFinalResultsAtTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResultBehaviorValidationError{
						field:  "FinalResultsAtTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResultBehaviorValidationError{
						field:  "FinalResultsAtTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFinalResultsAtTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResultBehaviorValidationError{
					field:  "FinalResultsAtTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		err := ResultBehaviorValidationError{
			field:  "ResultBehavior",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return ResultBehaviorMultiError(errors)
	}

	return nil
}

// ResultBehaviorMultiError is an error wrapping multiple validation errors
// returned by ResultBehavior.ValidateAll() if the designated constraints
// aren't met.
type ResultBehaviorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResultBehaviorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResultBehaviorMultiError) AllErrors() []error { return m }

// ResultBehaviorValidationError is the validation error returned by
// ResultBehavior.Validate if the designated constraints aren't met.
type ResultBehaviorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResultBehaviorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResultBehaviorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResultBehaviorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResultBehaviorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResultBehaviorValidationError) ErrorName() string { return "ResultBehaviorValidationError" }

// Error satisfies the builtin error interface
func (e ResultBehaviorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResultBehavior.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResultBehaviorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResultBehaviorValidationError{}

// Validate checks the field values on QueryLimits with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryLimits) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryLimits with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryLimitsMultiError, or
// nil if none found.
func (m *QueryLimits) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryLimits) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreviewRows

	if len(errors) > 0 {
		return QueryLimitsMultiError(errors)
	}

	return nil
}

// QueryLimitsMultiError is an error wrapping multiple validation errors
// returned by QueryLimits.ValidateAll() if the designated constraints aren't met.
type QueryLimitsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryLimitsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryLimitsMultiError) AllErrors() []error { return m }

// QueryLimitsValidationError is the validation error returned by
// QueryLimits.Validate if the designated constraints aren't met.
type QueryLimitsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryLimitsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryLimitsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryLimitsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryLimitsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryLimitsValidationError) ErrorName() string { return "QueryLimitsValidationError" }

// Error satisfies the builtin error interface
func (e QueryLimitsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryLimits.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryLimitsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryLimitsValidationError{}

// Validate checks the field values on QueryViews with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryViews) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryViews with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryViewsMultiError, or
// nil if none found.
func (m *QueryViews) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryViews) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetViews() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryViewsValidationError{
						field:  fmt.Sprintf("Views[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryViewsValidationError{
						field:  fmt.Sprintf("Views[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryViewsValidationError{
					field:  fmt.Sprintf("Views[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryViewsMultiError(errors)
	}

	return nil
}

// QueryViewsMultiError is an error wrapping multiple validation errors
// returned by QueryViews.ValidateAll() if the designated constraints aren't met.
type QueryViewsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryViewsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryViewsMultiError) AllErrors() []error { return m }

// QueryViewsValidationError is the validation error returned by
// QueryViews.Validate if the designated constraints aren't met.
type QueryViewsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryViewsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryViewsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryViewsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryViewsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryViewsValidationError) ErrorName() string { return "QueryViewsValidationError" }

// Error satisfies the builtin error interface
func (e QueryViewsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryViews.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryViewsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryViewsValidationError{}

// Validate checks the field values on QueryConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryConfigMultiError, or
// nil if none found.
func (m *QueryConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDataToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryConfigValidationError{
					field:  "DataToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryConfigValidationError{
					field:  "DataToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryConfigValidationError{
				field:  "DataToken",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSlice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryConfigValidationError{
					field:  "Slice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryConfigValidationError{
					field:  "Slice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSlice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryConfigValidationError{
				field:  "Slice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryConfigValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryConfigValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryConfigValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResultBehavior()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryConfigValidationError{
					field:  "ResultBehavior",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryConfigValidationError{
					field:  "ResultBehavior",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResultBehavior()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryConfigValidationError{
				field:  "ResultBehavior",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryConfigValidationError{
					field:  "Limits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryConfigValidationError{
					field:  "Limits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryConfigValidationError{
				field:  "Limits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueryConfigMultiError(errors)
	}

	return nil
}

// QueryConfigMultiError is an error wrapping multiple validation errors
// returned by QueryConfig.ValidateAll() if the designated constraints aren't met.
type QueryConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryConfigMultiError) AllErrors() []error { return m }

// QueryConfigValidationError is the validation error returned by
// QueryConfig.Validate if the designated constraints aren't met.
type QueryConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryConfigValidationError) ErrorName() string { return "QueryConfigValidationError" }

// Error satisfies the builtin error interface
func (e QueryConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryConfigValidationError{}

// Validate checks the field values on CSVResults with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CSVResults) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CSVResults with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CSVResultsMultiError, or
// nil if none found.
func (m *CSVResults) ValidateAll() error {
	return m.validate(true)
}

func (m *CSVResults) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CSVResultsMultiError(errors)
	}

	return nil
}

// CSVResultsMultiError is an error wrapping multiple validation errors
// returned by CSVResults.ValidateAll() if the designated constraints aren't met.
type CSVResultsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSVResultsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CSVResultsMultiError) AllErrors() []error { return m }

// CSVResultsValidationError is the validation error returned by
// CSVResults.Validate if the designated constraints aren't met.
type CSVResultsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CSVResultsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CSVResultsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CSVResultsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CSVResultsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CSVResultsValidationError) ErrorName() string { return "CSVResultsValidationError" }

// Error satisfies the builtin error interface
func (e CSVResultsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCSVResults.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CSVResultsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CSVResultsValidationError{}

// Validate checks the field values on ParquetResults with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ParquetResults) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParquetResults with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParquetResultsMultiError,
// or nil if none found.
func (m *ParquetResults) ValidateAll() error {
	return m.validate(true)
}

func (m *ParquetResults) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ParquetResultsMultiError(errors)
	}

	return nil
}

// ParquetResultsMultiError is an error wrapping multiple validation errors
// returned by ParquetResults.ValidateAll() if the designated constraints
// aren't met.
type ParquetResultsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParquetResultsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParquetResultsMultiError) AllErrors() []error { return m }

// ParquetResultsValidationError is the validation error returned by
// ParquetResults.Validate if the designated constraints aren't met.
type ParquetResultsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParquetResultsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParquetResultsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParquetResultsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParquetResultsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParquetResultsValidationError) ErrorName() string { return "ParquetResultsValidationError" }

// Error satisfies the builtin error interface
func (e ParquetResultsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParquetResults.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParquetResultsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParquetResultsValidationError{}

// Validate checks the field values on RedisBulkResults with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RedisBulkResults) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RedisBulkResults with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RedisBulkResultsMultiError, or nil if none found.
func (m *RedisBulkResults) ValidateAll() error {
	return m.validate(true)
}

func (m *RedisBulkResults) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RedisBulkResultsMultiError(errors)
	}

	return nil
}

// RedisBulkResultsMultiError is an error wrapping multiple validation errors
// returned by RedisBulkResults.ValidateAll() if the designated constraints
// aren't met.
type RedisBulkResultsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RedisBulkResultsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RedisBulkResultsMultiError) AllErrors() []error { return m }

// RedisBulkResultsValidationError is the validation error returned by
// RedisBulkResults.Validate if the designated constraints aren't met.
type RedisBulkResultsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RedisBulkResultsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RedisBulkResultsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RedisBulkResultsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RedisBulkResultsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RedisBulkResultsValidationError) ErrorName() string { return "RedisBulkResultsValidationError" }

// Error satisfies the builtin error interface
func (e RedisBulkResultsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRedisBulkResults.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RedisBulkResultsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RedisBulkResultsValidationError{}

// Validate checks the field values on QueryOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryOutputMultiError, or
// nil if none found.
func (m *QueryOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFileResults()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryOutputValidationError{
					field:  "FileResults",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryOutputValidationError{
					field:  "FileResults",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFileResults()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryOutputValidationError{
				field:  "FileResults",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueryOutputMultiError(errors)
	}

	return nil
}

// QueryOutputMultiError is an error wrapping multiple validation errors
// returned by QueryOutput.ValidateAll() if the designated constraints aren't met.
type QueryOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryOutputMultiError) AllErrors() []error { return m }

// QueryOutputValidationError is the validation error returned by
// QueryOutput.Validate if the designated constraints aren't met.
type QueryOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryOutputValidationError) ErrorName() string { return "QueryOutputValidationError" }

// Error satisfies the builtin error interface
func (e QueryOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryOutputValidationError{}

// Validate checks the field values on QueryResults with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryResults) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryResults with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryResultsMultiError, or
// nil if none found.
func (m *QueryResults) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryResults) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryResultsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryResultsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryResultsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFenlDiagnostics()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryResultsValidationError{
					field:  "FenlDiagnostics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryResultsValidationError{
					field:  "FenlDiagnostics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFenlDiagnostics()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryResultsValidationError{
				field:  "FenlDiagnostics",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryResultsValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryResultsValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryResultsValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueryResultsMultiError(errors)
	}

	return nil
}

// QueryResultsMultiError is an error wrapping multiple validation errors
// returned by QueryResults.ValidateAll() if the designated constraints aren't met.
type QueryResultsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryResultsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryResultsMultiError) AllErrors() []error { return m }

// QueryResultsValidationError is the validation error returned by
// QueryResults.Validate if the designated constraints aren't met.
type QueryResultsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryResultsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryResultsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryResultsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryResultsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryResultsValidationError) ErrorName() string { return "QueryResultsValidationError" }

// Error satisfies the builtin error interface
func (e QueryResultsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryResults.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryResultsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryResultsValidationError{}

// Validate checks the field values on QueryMetrics with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryMetrics) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryMetrics with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryMetricsMultiError, or
// nil if none found.
func (m *QueryMetrics) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryMetrics) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimePreparing()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryMetricsValidationError{
					field:  "TimePreparing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryMetricsValidationError{
					field:  "TimePreparing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimePreparing()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryMetricsValidationError{
				field:  "TimePreparing",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeComputing()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryMetricsValidationError{
					field:  "TimeComputing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryMetricsValidationError{
					field:  "TimeComputing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeComputing()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryMetricsValidationError{
				field:  "TimeComputing",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OutputFiles

	// no validation rules for TotalInputRows

	// no validation rules for ProcessedInputRows

	// no validation rules for ProducedOutputRows

	if len(errors) > 0 {
		return QueryMetricsMultiError(errors)
	}

	return nil
}

// QueryMetricsMultiError is an error wrapping multiple validation errors
// returned by QueryMetrics.ValidateAll() if the designated constraints aren't met.
type QueryMetricsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryMetricsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryMetricsMultiError) AllErrors() []error { return m }

// QueryMetricsValidationError is the validation error returned by
// QueryMetrics.Validate if the designated constraints aren't met.
type QueryMetricsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryMetricsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryMetricsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryMetricsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryMetricsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryMetricsValidationError) ErrorName() string { return "QueryMetricsValidationError" }

// Error satisfies the builtin error interface
func (e QueryMetricsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryMetrics.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryMetricsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryMetricsValidationError{}

// Validate checks the field values on Query with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Query) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Query with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QueryMultiError, or nil if none found.
func (m *Query) ValidateAll() error {
	return m.validate(true)
}

func (m *Query) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QueryId

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetExpression()) < 1 {
		err := QueryValidationError{
			field:  "Expression",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetViews()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "Views",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "Views",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetViews()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryValidationError{
				field:  "Views",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetResults()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "Results",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "Results",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResults()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryValidationError{
				field:  "Results",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetrics()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "Metrics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "Metrics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetrics()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryValidationError{
				field:  "Metrics",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueryMultiError(errors)
	}

	return nil
}

// QueryMultiError is an error wrapping multiple validation errors returned by
// Query.ValidateAll() if the designated constraints aren't met.
type QueryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryMultiError) AllErrors() []error { return m }

// QueryValidationError is the validation error returned by Query.Validate if
// the designated constraints aren't met.
type QueryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryValidationError) ErrorName() string { return "QueryValidationError" }

// Error satisfies the builtin error interface
func (e QueryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuery.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryValidationError{}

// Validate checks the field values on CreateQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQueryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateQueryRequestMultiError, or nil if none found.
func (m *CreateQueryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQueryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetExpression()) < 1 {
		err := CreateQueryRequestValidationError{
			field:  "Expression",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetViews()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryRequestValidationError{
					field:  "Views",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryRequestValidationError{
					field:  "Views",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetViews()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryRequestValidationError{
				field:  "Views",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryRequestValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DryRun

	if len(errors) > 0 {
		return CreateQueryRequestMultiError(errors)
	}

	return nil
}

// CreateQueryRequestMultiError is an error wrapping multiple validation errors
// returned by CreateQueryRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateQueryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQueryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQueryRequestMultiError) AllErrors() []error { return m }

// CreateQueryRequestValidationError is the validation error returned by
// CreateQueryRequest.Validate if the designated constraints aren't met.
type CreateQueryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQueryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQueryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQueryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQueryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQueryRequestValidationError) ErrorName() string {
	return "CreateQueryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQueryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQueryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQueryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQueryRequestValidationError{}

// Validate checks the field values on CreateQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQueryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateQueryResponseMultiError, or nil if none found.
func (m *CreateQueryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQueryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQuery()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "Query",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "Query",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuery()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryResponseValidationError{
				field:  "Query",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRequestDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "RequestDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "RequestDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryResponseValidationError{
				field:  "RequestDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateQueryResponseMultiError(errors)
	}

	return nil
}

// CreateQueryResponseMultiError is an error wrapping multiple validation
// errors returned by CreateQueryResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateQueryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQueryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQueryResponseMultiError) AllErrors() []error { return m }

// CreateQueryResponseValidationError is the validation error returned by
// CreateQueryResponse.Validate if the designated constraints aren't met.
type CreateQueryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQueryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQueryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQueryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQueryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQueryResponseValidationError) ErrorName() string {
	return "CreateQueryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQueryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQueryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQueryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQueryResponseValidationError{}

// Validate checks the field values on DeleteQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteQueryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteQueryRequestMultiError, or nil if none found.
func (m *DeleteQueryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteQueryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetQueryId()) < 1 {
		err := DeleteQueryRequestValidationError{
			field:  "QueryId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteQueryRequestMultiError(errors)
	}

	return nil
}

// DeleteQueryRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteQueryRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteQueryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteQueryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteQueryRequestMultiError) AllErrors() []error { return m }

// DeleteQueryRequestValidationError is the validation error returned by
// DeleteQueryRequest.Validate if the designated constraints aren't met.
type DeleteQueryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteQueryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteQueryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteQueryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteQueryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteQueryRequestValidationError) ErrorName() string {
	return "DeleteQueryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteQueryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteQueryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteQueryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteQueryRequestValidationError{}

// Validate checks the field values on DeleteQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteQueryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteQueryResponseMultiError, or nil if none found.
func (m *DeleteQueryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteQueryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequestDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteQueryResponseValidationError{
					field:  "RequestDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteQueryResponseValidationError{
					field:  "RequestDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteQueryResponseValidationError{
				field:  "RequestDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteQueryResponseMultiError(errors)
	}

	return nil
}

// DeleteQueryResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteQueryResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteQueryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteQueryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteQueryResponseMultiError) AllErrors() []error { return m }

// DeleteQueryResponseValidationError is the validation error returned by
// DeleteQueryResponse.Validate if the designated constraints aren't met.
type DeleteQueryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteQueryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteQueryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteQueryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteQueryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteQueryResponseValidationError) ErrorName() string {
	return "DeleteQueryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteQueryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteQueryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteQueryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteQueryResponseValidationError{}

// Validate checks the field values on GetQueryRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetQueryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetQueryRequestMultiError, or nil if none found.
func (m *GetQueryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQueryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetQueryId()) < 1 {
		err := GetQueryRequestValidationError{
			field:  "QueryId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PresignResults

	if len(errors) > 0 {
		return GetQueryRequestMultiError(errors)
	}

	return nil
}

// GetQueryRequestMultiError is an error wrapping multiple validation errors
// returned by GetQueryRequest.ValidateAll() if the designated constraints
// aren't met.
type GetQueryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQueryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQueryRequestMultiError) AllErrors() []error { return m }

// GetQueryRequestValidationError is the validation error returned by
// GetQueryRequest.Validate if the designated constraints aren't met.
type GetQueryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQueryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQueryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQueryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQueryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQueryRequestValidationError) ErrorName() string { return "GetQueryRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetQueryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQueryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQueryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQueryRequestValidationError{}

// Validate checks the field values on GetQueryResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetQueryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetQueryResponseMultiError, or nil if none found.
func (m *GetQueryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQueryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQuery()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetQueryResponseValidationError{
					field:  "Query",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetQueryResponseValidationError{
					field:  "Query",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuery()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetQueryResponseValidationError{
				field:  "Query",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRequestDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetQueryResponseValidationError{
					field:  "RequestDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetQueryResponseValidationError{
					field:  "RequestDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetQueryResponseValidationError{
				field:  "RequestDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetQueryResponseMultiError(errors)
	}

	return nil
}

// GetQueryResponseMultiError is an error wrapping multiple validation errors
// returned by GetQueryResponse.ValidateAll() if the designated constraints
// aren't met.
type GetQueryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQueryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQueryResponseMultiError) AllErrors() []error { return m }

// GetQueryResponseValidationError is the validation error returned by
// GetQueryResponse.Validate if the designated constraints aren't met.
type GetQueryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQueryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQueryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQueryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQueryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQueryResponseValidationError) ErrorName() string { return "GetQueryResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetQueryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQueryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQueryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQueryResponseValidationError{}

// Validate checks the field values on ListQueriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListQueriesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQueriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListQueriesRequestMultiError, or nil if none found.
func (m *ListQueriesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQueriesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Search

	if val := m.GetPageSize(); val < 0 || val > 1000 {
		err := ListQueriesRequestValidationError{
			field:  "PageSize",
			reason: "value must be inside range [0, 1000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageToken

	if len(errors) > 0 {
		return ListQueriesRequestMultiError(errors)
	}

	return nil
}

// ListQueriesRequestMultiError is an error wrapping multiple validation errors
// returned by ListQueriesRequest.ValidateAll() if the designated constraints
// aren't met.
type ListQueriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQueriesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQueriesRequestMultiError) AllErrors() []error { return m }

// ListQueriesRequestValidationError is the validation error returned by
// ListQueriesRequest.Validate if the designated constraints aren't met.
type ListQueriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQueriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQueriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQueriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQueriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQueriesRequestValidationError) ErrorName() string {
	return "ListQueriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListQueriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQueriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQueriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQueriesRequestValidationError{}

// Validate checks the field values on ListQueriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListQueriesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQueriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListQueriesResponseMultiError, or nil if none found.
func (m *ListQueriesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQueriesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetQueries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListQueriesResponseValidationError{
						field:  fmt.Sprintf("Queries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListQueriesResponseValidationError{
						field:  fmt.Sprintf("Queries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListQueriesResponseValidationError{
					field:  fmt.Sprintf("Queries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if all {
		switch v := interface{}(m.GetRequestDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListQueriesResponseValidationError{
					field:  "RequestDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListQueriesResponseValidationError{
					field:  "RequestDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListQueriesResponseValidationError{
				field:  "RequestDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListQueriesResponseMultiError(errors)
	}

	return nil
}

// ListQueriesResponseMultiError is an error wrapping multiple validation
// errors returned by ListQueriesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListQueriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQueriesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQueriesResponseMultiError) AllErrors() []error { return m }

// ListQueriesResponseValidationError is the validation error returned by
// ListQueriesResponse.Validate if the designated constraints aren't met.
type ListQueriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQueriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQueriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQueriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQueriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQueriesResponseValidationError) ErrorName() string {
	return "ListQueriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListQueriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQueriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQueriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQueriesResponseValidationError{}
