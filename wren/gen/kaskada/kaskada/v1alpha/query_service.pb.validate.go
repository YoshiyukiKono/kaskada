// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: kaskada/kaskada/v1alpha/query_service.proto

package kaskadav1alpha

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Query with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Query) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Query with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QueryMultiError, or nil if none found.
func (m *Query) ValidateAll() error {
	return m.validate(true)
}

func (m *Query) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QueryId

	if utf8.RuneCountInString(m.GetExpression()) < 1 {
		err := QueryValidationError{
			field:  "Expression",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDataTokenId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "DataTokenId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "DataTokenId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataTokenId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryValidationError{
				field:  "DataTokenId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetViews() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  fmt.Sprintf("Views[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  fmt.Sprintf("Views[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  fmt.Sprintf("Views[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ResultBehavior

	if all {
		switch v := interface{}(m.GetLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "Limits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "Limits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryValidationError{
				field:  "Limits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSlice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "Slice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "Slice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSlice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryValidationError{
				field:  "Slice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetChangedSinceTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "ChangedSinceTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "ChangedSinceTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChangedSinceTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryValidationError{
				field:  "ChangedSinceTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinalResultTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "FinalResultTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "FinalResultTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalResultTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryValidationError{
				field:  "FinalResultTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.ResponseAs.(type) {

	case *Query_AsFiles:

		if all {
			switch v := interface{}(m.GetAsFiles()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "AsFiles",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "AsFiles",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAsFiles()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "AsFiles",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_RedisAI_:

		if all {
			switch v := interface{}(m.GetRedisAI()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "RedisAI",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "RedisAI",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRedisAI()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "RedisAI",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_Pulsar_:

		if all {
			switch v := interface{}(m.GetPulsar()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "Pulsar",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "Pulsar",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPulsar()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "Pulsar",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		err := QueryValidationError{
			field:  "ResponseAs",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return QueryMultiError(errors)
	}

	return nil
}

// QueryMultiError is an error wrapping multiple validation errors returned by
// Query.ValidateAll() if the designated constraints aren't met.
type QueryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryMultiError) AllErrors() []error { return m }

// QueryValidationError is the validation error returned by Query.Validate if
// the designated constraints aren't met.
type QueryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryValidationError) ErrorName() string { return "QueryValidationError" }

// Error satisfies the builtin error interface
func (e QueryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuery.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryValidationError{}

// Validate checks the field values on QueryOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryOptionsMultiError, or
// nil if none found.
func (m *QueryOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DryRun

	// no validation rules for ExperimentalFeatures

	// no validation rules for StreamMetrics

	// no validation rules for PresignResults

	if len(errors) > 0 {
		return QueryOptionsMultiError(errors)
	}

	return nil
}

// QueryOptionsMultiError is an error wrapping multiple validation errors
// returned by QueryOptions.ValidateAll() if the designated constraints aren't met.
type QueryOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryOptionsMultiError) AllErrors() []error { return m }

// QueryOptionsValidationError is the validation error returned by
// QueryOptions.Validate if the designated constraints aren't met.
type QueryOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryOptionsValidationError) ErrorName() string { return "QueryOptionsValidationError" }

// Error satisfies the builtin error interface
func (e QueryOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryOptionsValidationError{}

// Validate checks the field values on CreateQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQueryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateQueryRequestMultiError, or nil if none found.
func (m *CreateQueryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQueryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQuery()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryRequestValidationError{
					field:  "Query",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryRequestValidationError{
					field:  "Query",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuery()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryRequestValidationError{
				field:  "Query",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQueryOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryRequestValidationError{
					field:  "QueryOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryRequestValidationError{
					field:  "QueryOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueryOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryRequestValidationError{
				field:  "QueryOptions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateQueryRequestMultiError(errors)
	}

	return nil
}

// CreateQueryRequestMultiError is an error wrapping multiple validation errors
// returned by CreateQueryRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateQueryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQueryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQueryRequestMultiError) AllErrors() []error { return m }

// CreateQueryRequestValidationError is the validation error returned by
// CreateQueryRequest.Validate if the designated constraints aren't met.
type CreateQueryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQueryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQueryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQueryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQueryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQueryRequestValidationError) ErrorName() string {
	return "CreateQueryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQueryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQueryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQueryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQueryRequestValidationError{}

// Validate checks the field values on CreateQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQueryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateQueryResponseMultiError, or nil if none found.
func (m *CreateQueryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQueryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryResponseValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAnalysis()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "Analysis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "Analysis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnalysis()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryResponseValidationError{
				field:  "Analysis",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFenlDiagnostics()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "FenlDiagnostics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "FenlDiagnostics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFenlDiagnostics()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryResponseValidationError{
				field:  "FenlDiagnostics",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetrics()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "Metrics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "Metrics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetrics()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryResponseValidationError{
				field:  "Metrics",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRequestDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "RequestDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryResponseValidationError{
					field:  "RequestDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryResponseValidationError{
				field:  "RequestDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for QueryId

	switch m.Results.(type) {

	case *CreateQueryResponse_FileResults:

		if all {
			switch v := interface{}(m.GetFileResults()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateQueryResponseValidationError{
						field:  "FileResults",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateQueryResponseValidationError{
						field:  "FileResults",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFileResults()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateQueryResponseValidationError{
					field:  "FileResults",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CreateQueryResponse_RedisAI_:

		if all {
			switch v := interface{}(m.GetRedisAI()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateQueryResponseValidationError{
						field:  "RedisAI",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateQueryResponseValidationError{
						field:  "RedisAI",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRedisAI()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateQueryResponseValidationError{
					field:  "RedisAI",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CreateQueryResponse_Pulsar_:

		if all {
			switch v := interface{}(m.GetPulsar()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateQueryResponseValidationError{
						field:  "Pulsar",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateQueryResponseValidationError{
						field:  "Pulsar",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPulsar()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateQueryResponseValidationError{
					field:  "Pulsar",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateQueryResponseMultiError(errors)
	}

	return nil
}

// CreateQueryResponseMultiError is an error wrapping multiple validation
// errors returned by CreateQueryResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateQueryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQueryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQueryResponseMultiError) AllErrors() []error { return m }

// CreateQueryResponseValidationError is the validation error returned by
// CreateQueryResponse.Validate if the designated constraints aren't met.
type CreateQueryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQueryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQueryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQueryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQueryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQueryResponseValidationError) ErrorName() string {
	return "CreateQueryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQueryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQueryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQueryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQueryResponseValidationError{}

// Validate checks the field values on GetQueryRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetQueryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetQueryRequestMultiError, or nil if none found.
func (m *GetQueryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQueryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetQueryId()) < 1 {
		err := GetQueryRequestValidationError{
			field:  "QueryId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetQueryRequestMultiError(errors)
	}

	return nil
}

// GetQueryRequestMultiError is an error wrapping multiple validation errors
// returned by GetQueryRequest.ValidateAll() if the designated constraints
// aren't met.
type GetQueryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQueryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQueryRequestMultiError) AllErrors() []error { return m }

// GetQueryRequestValidationError is the validation error returned by
// GetQueryRequest.Validate if the designated constraints aren't met.
type GetQueryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQueryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQueryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQueryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQueryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQueryRequestValidationError) ErrorName() string { return "GetQueryRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetQueryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQueryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQueryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQueryRequestValidationError{}

// Validate checks the field values on GetQueryResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetQueryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetQueryResponseMultiError, or nil if none found.
func (m *GetQueryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQueryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQuery()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetQueryResponseValidationError{
					field:  "Query",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetQueryResponseValidationError{
					field:  "Query",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuery()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetQueryResponseValidationError{
				field:  "Query",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetQueryResponseMultiError(errors)
	}

	return nil
}

// GetQueryResponseMultiError is an error wrapping multiple validation errors
// returned by GetQueryResponse.ValidateAll() if the designated constraints
// aren't met.
type GetQueryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQueryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQueryResponseMultiError) AllErrors() []error { return m }

// GetQueryResponseValidationError is the validation error returned by
// GetQueryResponse.Validate if the designated constraints aren't met.
type GetQueryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQueryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQueryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQueryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQueryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQueryResponseValidationError) ErrorName() string { return "GetQueryResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetQueryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQueryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQueryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQueryResponseValidationError{}

// Validate checks the field values on ListQueriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListQueriesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQueriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListQueriesRequestMultiError, or nil if none found.
func (m *ListQueriesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQueriesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Search

	if val := m.GetPageSize(); val < 0 || val > 1000 {
		err := ListQueriesRequestValidationError{
			field:  "PageSize",
			reason: "value must be inside range [0, 1000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageToken

	if len(errors) > 0 {
		return ListQueriesRequestMultiError(errors)
	}

	return nil
}

// ListQueriesRequestMultiError is an error wrapping multiple validation errors
// returned by ListQueriesRequest.ValidateAll() if the designated constraints
// aren't met.
type ListQueriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQueriesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQueriesRequestMultiError) AllErrors() []error { return m }

// ListQueriesRequestValidationError is the validation error returned by
// ListQueriesRequest.Validate if the designated constraints aren't met.
type ListQueriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQueriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQueriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQueriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQueriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQueriesRequestValidationError) ErrorName() string {
	return "ListQueriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListQueriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQueriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQueriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQueriesRequestValidationError{}

// Validate checks the field values on ListQueriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListQueriesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQueriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListQueriesResponseMultiError, or nil if none found.
func (m *ListQueriesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQueriesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetQueries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListQueriesResponseValidationError{
						field:  fmt.Sprintf("Queries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListQueriesResponseValidationError{
						field:  fmt.Sprintf("Queries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListQueriesResponseValidationError{
					field:  fmt.Sprintf("Queries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if all {
		switch v := interface{}(m.GetRequestDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListQueriesResponseValidationError{
					field:  "RequestDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListQueriesResponseValidationError{
					field:  "RequestDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListQueriesResponseValidationError{
				field:  "RequestDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListQueriesResponseMultiError(errors)
	}

	return nil
}

// ListQueriesResponseMultiError is an error wrapping multiple validation
// errors returned by ListQueriesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListQueriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQueriesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQueriesResponseMultiError) AllErrors() []error { return m }

// ListQueriesResponseValidationError is the validation error returned by
// ListQueriesResponse.Validate if the designated constraints aren't met.
type ListQueriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQueriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQueriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQueriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQueriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQueriesResponseValidationError) ErrorName() string {
	return "ListQueriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListQueriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQueriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQueriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQueriesResponseValidationError{}

// Validate checks the field values on Query_Limits with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Query_Limits) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Query_Limits with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Query_LimitsMultiError, or
// nil if none found.
func (m *Query_Limits) ValidateAll() error {
	return m.validate(true)
}

func (m *Query_Limits) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreviewRows

	if len(errors) > 0 {
		return Query_LimitsMultiError(errors)
	}

	return nil
}

// Query_LimitsMultiError is an error wrapping multiple validation errors
// returned by Query_Limits.ValidateAll() if the designated constraints aren't met.
type Query_LimitsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Query_LimitsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Query_LimitsMultiError) AllErrors() []error { return m }

// Query_LimitsValidationError is the validation error returned by
// Query_Limits.Validate if the designated constraints aren't met.
type Query_LimitsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Query_LimitsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Query_LimitsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Query_LimitsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Query_LimitsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Query_LimitsValidationError) ErrorName() string { return "Query_LimitsValidationError" }

// Error satisfies the builtin error interface
func (e Query_LimitsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuery_Limits.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Query_LimitsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Query_LimitsValidationError{}

// Validate checks the field values on Query_RedisBulkResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Query_RedisBulkResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Query_RedisBulkResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Query_RedisBulkResponseMultiError, or nil if none found.
func (m *Query_RedisBulkResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *Query_RedisBulkResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Query_RedisBulkResponseMultiError(errors)
	}

	return nil
}

// Query_RedisBulkResponseMultiError is an error wrapping multiple validation
// errors returned by Query_RedisBulkResponse.ValidateAll() if the designated
// constraints aren't met.
type Query_RedisBulkResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Query_RedisBulkResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Query_RedisBulkResponseMultiError) AllErrors() []error { return m }

// Query_RedisBulkResponseValidationError is the validation error returned by
// Query_RedisBulkResponse.Validate if the designated constraints aren't met.
type Query_RedisBulkResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Query_RedisBulkResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Query_RedisBulkResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Query_RedisBulkResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Query_RedisBulkResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Query_RedisBulkResponseValidationError) ErrorName() string {
	return "Query_RedisBulkResponseValidationError"
}

// Error satisfies the builtin error interface
func (e Query_RedisBulkResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuery_RedisBulkResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Query_RedisBulkResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Query_RedisBulkResponseValidationError{}

// Validate checks the field values on Query_RedisAI with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Query_RedisAI) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Query_RedisAI with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Query_RedisAIMultiError, or
// nil if none found.
func (m *Query_RedisAI) ValidateAll() error {
	return m.validate(true)
}

func (m *Query_RedisAI) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetDb(); val < 0 || val > 15 {
		err := Query_RedisAIValidationError{
			field:  "Db",
			reason: "value must be inside range [0, 15]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetHost()) < 1 {
		err := Query_RedisAIValidationError{
			field:  "Host",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetPort(); val <= 0 || val > 65535 {
		err := Query_RedisAIValidationError{
			field:  "Port",
			reason: "value must be inside range (0, 65535]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Query_RedisAIMultiError(errors)
	}

	return nil
}

// Query_RedisAIMultiError is an error wrapping multiple validation errors
// returned by Query_RedisAI.ValidateAll() if the designated constraints
// aren't met.
type Query_RedisAIMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Query_RedisAIMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Query_RedisAIMultiError) AllErrors() []error { return m }

// Query_RedisAIValidationError is the validation error returned by
// Query_RedisAI.Validate if the designated constraints aren't met.
type Query_RedisAIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Query_RedisAIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Query_RedisAIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Query_RedisAIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Query_RedisAIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Query_RedisAIValidationError) ErrorName() string { return "Query_RedisAIValidationError" }

// Error satisfies the builtin error interface
func (e Query_RedisAIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuery_RedisAI.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Query_RedisAIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Query_RedisAIValidationError{}

// Validate checks the field values on Query_Pulsar with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Query_Pulsar) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Query_Pulsar with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Query_PulsarMultiError, or
// nil if none found.
func (m *Query_Pulsar) ValidateAll() error {
	return m.validate(true)
}

func (m *Query_Pulsar) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Tenant

	// no validation rules for Namespace

	if len(errors) > 0 {
		return Query_PulsarMultiError(errors)
	}

	return nil
}

// Query_PulsarMultiError is an error wrapping multiple validation errors
// returned by Query_Pulsar.ValidateAll() if the designated constraints aren't met.
type Query_PulsarMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Query_PulsarMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Query_PulsarMultiError) AllErrors() []error { return m }

// Query_PulsarValidationError is the validation error returned by
// Query_Pulsar.Validate if the designated constraints aren't met.
type Query_PulsarValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Query_PulsarValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Query_PulsarValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Query_PulsarValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Query_PulsarValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Query_PulsarValidationError) ErrorName() string { return "Query_PulsarValidationError" }

// Error satisfies the builtin error interface
func (e Query_PulsarValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuery_Pulsar.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Query_PulsarValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Query_PulsarValidationError{}

// Validate checks the field values on CreateQueryResponse_Analysis with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQueryResponse_Analysis) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQueryResponse_Analysis with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateQueryResponse_AnalysisMultiError, or nil if none found.
func (m *CreateQueryResponse_Analysis) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQueryResponse_Analysis) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CanExecute

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryResponse_AnalysisValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryResponse_AnalysisValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryResponse_AnalysisValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateQueryResponse_AnalysisMultiError(errors)
	}

	return nil
}

// CreateQueryResponse_AnalysisMultiError is an error wrapping multiple
// validation errors returned by CreateQueryResponse_Analysis.ValidateAll() if
// the designated constraints aren't met.
type CreateQueryResponse_AnalysisMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQueryResponse_AnalysisMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQueryResponse_AnalysisMultiError) AllErrors() []error { return m }

// CreateQueryResponse_AnalysisValidationError is the validation error returned
// by CreateQueryResponse_Analysis.Validate if the designated constraints
// aren't met.
type CreateQueryResponse_AnalysisValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQueryResponse_AnalysisValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQueryResponse_AnalysisValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQueryResponse_AnalysisValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQueryResponse_AnalysisValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQueryResponse_AnalysisValidationError) ErrorName() string {
	return "CreateQueryResponse_AnalysisValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQueryResponse_AnalysisValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQueryResponse_Analysis.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQueryResponse_AnalysisValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQueryResponse_AnalysisValidationError{}

// Validate checks the field values on CreateQueryResponse_Config with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQueryResponse_Config) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQueryResponse_Config with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateQueryResponse_ConfigMultiError, or nil if none found.
func (m *CreateQueryResponse_Config) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQueryResponse_Config) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DataTokenId

	if all {
		switch v := interface{}(m.GetSliceRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryResponse_ConfigValidationError{
					field:  "SliceRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryResponse_ConfigValidationError{
					field:  "SliceRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSliceRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryResponse_ConfigValidationError{
				field:  "SliceRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateQueryResponse_ConfigMultiError(errors)
	}

	return nil
}

// CreateQueryResponse_ConfigMultiError is an error wrapping multiple
// validation errors returned by CreateQueryResponse_Config.ValidateAll() if
// the designated constraints aren't met.
type CreateQueryResponse_ConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQueryResponse_ConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQueryResponse_ConfigMultiError) AllErrors() []error { return m }

// CreateQueryResponse_ConfigValidationError is the validation error returned
// by CreateQueryResponse_Config.Validate if the designated constraints aren't met.
type CreateQueryResponse_ConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQueryResponse_ConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQueryResponse_ConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQueryResponse_ConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQueryResponse_ConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQueryResponse_ConfigValidationError) ErrorName() string {
	return "CreateQueryResponse_ConfigValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQueryResponse_ConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQueryResponse_Config.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQueryResponse_ConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQueryResponse_ConfigValidationError{}

// Validate checks the field values on CreateQueryResponse_Metrics with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQueryResponse_Metrics) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQueryResponse_Metrics with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateQueryResponse_MetricsMultiError, or nil if none found.
func (m *CreateQueryResponse_Metrics) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQueryResponse_Metrics) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimePreparing()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryResponse_MetricsValidationError{
					field:  "TimePreparing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryResponse_MetricsValidationError{
					field:  "TimePreparing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimePreparing()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryResponse_MetricsValidationError{
				field:  "TimePreparing",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeComputing()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQueryResponse_MetricsValidationError{
					field:  "TimeComputing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQueryResponse_MetricsValidationError{
					field:  "TimeComputing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeComputing()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQueryResponse_MetricsValidationError{
				field:  "TimeComputing",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OutputFiles

	// no validation rules for TotalInputRows

	// no validation rules for ProcessedInputRows

	// no validation rules for ProducedOutputRows

	if len(errors) > 0 {
		return CreateQueryResponse_MetricsMultiError(errors)
	}

	return nil
}

// CreateQueryResponse_MetricsMultiError is an error wrapping multiple
// validation errors returned by CreateQueryResponse_Metrics.ValidateAll() if
// the designated constraints aren't met.
type CreateQueryResponse_MetricsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQueryResponse_MetricsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQueryResponse_MetricsMultiError) AllErrors() []error { return m }

// CreateQueryResponse_MetricsValidationError is the validation error returned
// by CreateQueryResponse_Metrics.Validate if the designated constraints
// aren't met.
type CreateQueryResponse_MetricsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQueryResponse_MetricsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQueryResponse_MetricsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQueryResponse_MetricsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQueryResponse_MetricsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQueryResponse_MetricsValidationError) ErrorName() string {
	return "CreateQueryResponse_MetricsValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQueryResponse_MetricsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQueryResponse_Metrics.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQueryResponse_MetricsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQueryResponse_MetricsValidationError{}

// Validate checks the field values on CreateQueryResponse_RedisAI with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQueryResponse_RedisAI) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQueryResponse_RedisAI with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateQueryResponse_RedisAIMultiError, or nil if none found.
func (m *CreateQueryResponse_RedisAI) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQueryResponse_RedisAI) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CreateQueryResponse_RedisAIMultiError(errors)
	}

	return nil
}

// CreateQueryResponse_RedisAIMultiError is an error wrapping multiple
// validation errors returned by CreateQueryResponse_RedisAI.ValidateAll() if
// the designated constraints aren't met.
type CreateQueryResponse_RedisAIMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQueryResponse_RedisAIMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQueryResponse_RedisAIMultiError) AllErrors() []error { return m }

// CreateQueryResponse_RedisAIValidationError is the validation error returned
// by CreateQueryResponse_RedisAI.Validate if the designated constraints
// aren't met.
type CreateQueryResponse_RedisAIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQueryResponse_RedisAIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQueryResponse_RedisAIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQueryResponse_RedisAIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQueryResponse_RedisAIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQueryResponse_RedisAIValidationError) ErrorName() string {
	return "CreateQueryResponse_RedisAIValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQueryResponse_RedisAIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQueryResponse_RedisAI.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQueryResponse_RedisAIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQueryResponse_RedisAIValidationError{}

// Validate checks the field values on CreateQueryResponse_Pulsar with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQueryResponse_Pulsar) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQueryResponse_Pulsar with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateQueryResponse_PulsarMultiError, or nil if none found.
func (m *CreateQueryResponse_Pulsar) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQueryResponse_Pulsar) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TopicUrl

	if len(errors) > 0 {
		return CreateQueryResponse_PulsarMultiError(errors)
	}

	return nil
}

// CreateQueryResponse_PulsarMultiError is an error wrapping multiple
// validation errors returned by CreateQueryResponse_Pulsar.ValidateAll() if
// the designated constraints aren't met.
type CreateQueryResponse_PulsarMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQueryResponse_PulsarMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQueryResponse_PulsarMultiError) AllErrors() []error { return m }

// CreateQueryResponse_PulsarValidationError is the validation error returned
// by CreateQueryResponse_Pulsar.Validate if the designated constraints aren't met.
type CreateQueryResponse_PulsarValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQueryResponse_PulsarValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQueryResponse_PulsarValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQueryResponse_PulsarValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQueryResponse_PulsarValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQueryResponse_PulsarValidationError) ErrorName() string {
	return "CreateQueryResponse_PulsarValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQueryResponse_PulsarValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQueryResponse_Pulsar.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQueryResponse_PulsarValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQueryResponse_PulsarValidationError{}
