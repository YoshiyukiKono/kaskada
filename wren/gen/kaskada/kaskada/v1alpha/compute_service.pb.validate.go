// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: kaskada/kaskada/v1alpha/compute_service.proto

package kaskadav1alpha

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on FeatureSet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FeatureSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FeatureSet with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FeatureSetMultiError, or
// nil if none found.
func (m *FeatureSet) ValidateAll() error {
	return m.validate(true)
}

func (m *FeatureSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFormulas() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FeatureSetValidationError{
						field:  fmt.Sprintf("Formulas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FeatureSetValidationError{
						field:  fmt.Sprintf("Formulas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FeatureSetValidationError{
					field:  fmt.Sprintf("Formulas[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Query

	if len(errors) > 0 {
		return FeatureSetMultiError(errors)
	}

	return nil
}

// FeatureSetMultiError is an error wrapping multiple validation errors
// returned by FeatureSet.ValidateAll() if the designated constraints aren't met.
type FeatureSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FeatureSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FeatureSetMultiError) AllErrors() []error { return m }

// FeatureSetValidationError is the validation error returned by
// FeatureSet.Validate if the designated constraints aren't met.
type FeatureSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FeatureSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FeatureSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FeatureSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FeatureSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FeatureSetValidationError) ErrorName() string { return "FeatureSetValidationError" }

// Error satisfies the builtin error interface
func (e FeatureSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFeatureSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FeatureSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FeatureSetValidationError{}

// Validate checks the field values on Formula with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Formula) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Formula with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FormulaMultiError, or nil if none found.
func (m *Formula) ValidateAll() error {
	return m.validate(true)
}

func (m *Formula) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Formula

	// no validation rules for SourceLocation

	if len(errors) > 0 {
		return FormulaMultiError(errors)
	}

	return nil
}

// FormulaMultiError is an error wrapping multiple validation errors returned
// by Formula.ValidateAll() if the designated constraints aren't met.
type FormulaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FormulaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FormulaMultiError) AllErrors() []error { return m }

// FormulaValidationError is the validation error returned by Formula.Validate
// if the designated constraints aren't met.
type FormulaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FormulaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FormulaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FormulaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FormulaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FormulaValidationError) ErrorName() string { return "FormulaValidationError" }

// Error satisfies the builtin error interface
func (e FormulaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFormula.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FormulaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FormulaValidationError{}

// Validate checks the field values on ComputeTable with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ComputeTable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComputeTable with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ComputeTableMultiError, or
// nil if none found.
func (m *ComputeTable) ValidateAll() error {
	return m.validate(true)
}

func (m *ComputeTable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComputeTableValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComputeTableValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComputeTableValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComputeTableValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComputeTableValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComputeTableValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetFileSets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComputeTableValidationError{
						field:  fmt.Sprintf("FileSets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComputeTableValidationError{
						field:  fmt.Sprintf("FileSets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComputeTableValidationError{
					field:  fmt.Sprintf("FileSets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ComputeTableMultiError(errors)
	}

	return nil
}

// ComputeTableMultiError is an error wrapping multiple validation errors
// returned by ComputeTable.ValidateAll() if the designated constraints aren't met.
type ComputeTableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComputeTableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComputeTableMultiError) AllErrors() []error { return m }

// ComputeTableValidationError is the validation error returned by
// ComputeTable.Validate if the designated constraints aren't met.
type ComputeTableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComputeTableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComputeTableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComputeTableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComputeTableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComputeTableValidationError) ErrorName() string { return "ComputeTableValidationError" }

// Error satisfies the builtin error interface
func (e ComputeTableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComputeTable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComputeTableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComputeTableValidationError{}

// Validate checks the field values on PlanHash with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlanHash) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlanHash with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlanHashMultiError, or nil
// if none found.
func (m *PlanHash) ValidateAll() error {
	return m.validate(true)
}

func (m *PlanHash) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hash

	if len(errors) > 0 {
		return PlanHashMultiError(errors)
	}

	return nil
}

// PlanHashMultiError is an error wrapping multiple validation errors returned
// by PlanHash.ValidateAll() if the designated constraints aren't met.
type PlanHashMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlanHashMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlanHashMultiError) AllErrors() []error { return m }

// PlanHashValidationError is the validation error returned by
// PlanHash.Validate if the designated constraints aren't met.
type PlanHashValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlanHashValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlanHashValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlanHashValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlanHashValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlanHashValidationError) ErrorName() string { return "PlanHashValidationError" }

// Error satisfies the builtin error interface
func (e PlanHashValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlanHash.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlanHashValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlanHashValidationError{}

// Validate checks the field values on GetCurrentSnapshotVersionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetCurrentSnapshotVersionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCurrentSnapshotVersionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetCurrentSnapshotVersionRequestMultiError, or nil if none found.
func (m *GetCurrentSnapshotVersionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCurrentSnapshotVersionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetCurrentSnapshotVersionRequestMultiError(errors)
	}

	return nil
}

// GetCurrentSnapshotVersionRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetCurrentSnapshotVersionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetCurrentSnapshotVersionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCurrentSnapshotVersionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCurrentSnapshotVersionRequestMultiError) AllErrors() []error { return m }

// GetCurrentSnapshotVersionRequestValidationError is the validation error
// returned by GetCurrentSnapshotVersionRequest.Validate if the designated
// constraints aren't met.
type GetCurrentSnapshotVersionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCurrentSnapshotVersionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCurrentSnapshotVersionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCurrentSnapshotVersionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCurrentSnapshotVersionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCurrentSnapshotVersionRequestValidationError) ErrorName() string {
	return "GetCurrentSnapshotVersionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCurrentSnapshotVersionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCurrentSnapshotVersionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCurrentSnapshotVersionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCurrentSnapshotVersionRequestValidationError{}

// Validate checks the field values on GetCurrentSnapshotVersionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetCurrentSnapshotVersionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCurrentSnapshotVersionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetCurrentSnapshotVersionResponseMultiError, or nil if none found.
func (m *GetCurrentSnapshotVersionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCurrentSnapshotVersionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SnapshotVersion

	if len(errors) > 0 {
		return GetCurrentSnapshotVersionResponseMultiError(errors)
	}

	return nil
}

// GetCurrentSnapshotVersionResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetCurrentSnapshotVersionResponse.ValidateAll() if the designated
// constraints aren't met.
type GetCurrentSnapshotVersionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCurrentSnapshotVersionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCurrentSnapshotVersionResponseMultiError) AllErrors() []error { return m }

// GetCurrentSnapshotVersionResponseValidationError is the validation error
// returned by GetCurrentSnapshotVersionResponse.Validate if the designated
// constraints aren't met.
type GetCurrentSnapshotVersionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCurrentSnapshotVersionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCurrentSnapshotVersionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCurrentSnapshotVersionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCurrentSnapshotVersionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCurrentSnapshotVersionResponseValidationError) ErrorName() string {
	return "GetCurrentSnapshotVersionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCurrentSnapshotVersionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCurrentSnapshotVersionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCurrentSnapshotVersionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCurrentSnapshotVersionResponseValidationError{}

// Validate checks the field values on CompileRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CompileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CompileRequestMultiError,
// or nil if none found.
func (m *CompileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CompileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTables() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompileRequestValidationError{
						field:  fmt.Sprintf("Tables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompileRequestValidationError{
						field:  fmt.Sprintf("Tables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompileRequestValidationError{
					field:  fmt.Sprintf("Tables[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetFeatureSet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompileRequestValidationError{
					field:  "FeatureSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompileRequestValidationError{
					field:  "FeatureSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFeatureSet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompileRequestValidationError{
				field:  "FeatureSet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSliceRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompileRequestValidationError{
					field:  "SliceRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompileRequestValidationError{
					field:  "SliceRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSliceRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompileRequestValidationError{
				field:  "SliceRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExpressionKind

	// no validation rules for Experimental

	// no validation rules for PerEntityBehavior

	if len(errors) > 0 {
		return CompileRequestMultiError(errors)
	}

	return nil
}

// CompileRequestMultiError is an error wrapping multiple validation errors
// returned by CompileRequest.ValidateAll() if the designated constraints
// aren't met.
type CompileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompileRequestMultiError) AllErrors() []error { return m }

// CompileRequestValidationError is the validation error returned by
// CompileRequest.Validate if the designated constraints aren't met.
type CompileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompileRequestValidationError) ErrorName() string { return "CompileRequestValidationError" }

// Error satisfies the builtin error interface
func (e CompileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompileRequestValidationError{}

// Validate checks the field values on CompileResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CompileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompileResponseMultiError, or nil if none found.
func (m *CompileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CompileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFenlDiagnostics()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompileResponseValidationError{
					field:  "FenlDiagnostics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompileResponseValidationError{
					field:  "FenlDiagnostics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFenlDiagnostics()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompileResponseValidationError{
				field:  "FenlDiagnostics",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompileResponseValidationError{
					field:  "Plan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompileResponseValidationError{
					field:  "Plan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompileResponseValidationError{
				field:  "Plan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResultType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompileResponseValidationError{
					field:  "ResultType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompileResponseValidationError{
					field:  "ResultType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResultType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompileResponseValidationError{
				field:  "ResultType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTableSlices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompileResponseValidationError{
						field:  fmt.Sprintf("TableSlices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompileResponseValidationError{
						field:  fmt.Sprintf("TableSlices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompileResponseValidationError{
					field:  fmt.Sprintf("TableSlices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IncrementalEnabled

	if all {
		switch v := interface{}(m.GetPlanHash()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompileResponseValidationError{
					field:  "PlanHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompileResponseValidationError{
					field:  "PlanHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlanHash()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompileResponseValidationError{
				field:  "PlanHash",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CompileResponseMultiError(errors)
	}

	return nil
}

// CompileResponseMultiError is an error wrapping multiple validation errors
// returned by CompileResponse.ValidateAll() if the designated constraints
// aren't met.
type CompileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompileResponseMultiError) AllErrors() []error { return m }

// CompileResponseValidationError is the validation error returned by
// CompileResponse.Validate if the designated constraints aren't met.
type CompileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompileResponseValidationError) ErrorName() string { return "CompileResponseValidationError" }

// Error satisfies the builtin error interface
func (e CompileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompileResponseValidationError{}

// Validate checks the field values on ExecuteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExecuteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExecuteRequestMultiError,
// or nil if none found.
func (m *ExecuteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Plan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Plan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequestValidationError{
				field:  "Plan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTables() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteRequestValidationError{
						field:  fmt.Sprintf("Tables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteRequestValidationError{
						field:  fmt.Sprintf("Tables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteRequestValidationError{
					field:  fmt.Sprintf("Tables[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOutputTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "OutputTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "OutputTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutputTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequestValidationError{
				field:  "OutputTo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Limits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Limits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequestValidationError{
				field:  "Limits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetComputeSnapshotConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "ComputeSnapshotConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "ComputeSnapshotConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetComputeSnapshotConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequestValidationError{
				field:  "ComputeSnapshotConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetChangedSince()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "ChangedSince",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "ChangedSince",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChangedSince()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequestValidationError{
				field:  "ChangedSince",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinalResultTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "FinalResultTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "FinalResultTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalResultTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequestValidationError{
				field:  "FinalResultTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExecuteRequestMultiError(errors)
	}

	return nil
}

// ExecuteRequestMultiError is an error wrapping multiple validation errors
// returned by ExecuteRequest.ValidateAll() if the designated constraints
// aren't met.
type ExecuteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteRequestMultiError) AllErrors() []error { return m }

// ExecuteRequestValidationError is the validation error returned by
// ExecuteRequest.Validate if the designated constraints aren't met.
type ExecuteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteRequestValidationError) ErrorName() string { return "ExecuteRequestValidationError" }

// Error satisfies the builtin error interface
func (e ExecuteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteRequestValidationError{}

// Validate checks the field values on ExecuteResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExecuteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecuteResponseMultiError, or nil if none found.
func (m *ExecuteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for State

	// no validation rules for IsQueryDone

	if all {
		switch v := interface{}(m.GetProgress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "Progress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "Progress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProgress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteResponseValidationError{
				field:  "Progress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFlightRecordPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "FlightRecordPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "FlightRecordPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFlightRecordPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteResponseValidationError{
				field:  "FlightRecordPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlanYamlPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "PlanYamlPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "PlanYamlPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlanYamlPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteResponseValidationError{
				field:  "PlanYamlPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetComputeSnapshots() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteResponseValidationError{
						field:  fmt.Sprintf("ComputeSnapshots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteResponseValidationError{
						field:  fmt.Sprintf("ComputeSnapshots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteResponseValidationError{
					field:  fmt.Sprintf("ComputeSnapshots[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteResponseValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExecuteResponseMultiError(errors)
	}

	return nil
}

// ExecuteResponseMultiError is an error wrapping multiple validation errors
// returned by ExecuteResponse.ValidateAll() if the designated constraints
// aren't met.
type ExecuteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteResponseMultiError) AllErrors() []error { return m }

// ExecuteResponseValidationError is the validation error returned by
// ExecuteResponse.Validate if the designated constraints aren't met.
type ExecuteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteResponseValidationError) ErrorName() string { return "ExecuteResponseValidationError" }

// Error satisfies the builtin error interface
func (e ExecuteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteResponseValidationError{}

// Validate checks the field values on ComputeTable_FileSet with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ComputeTable_FileSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComputeTable_FileSet with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ComputeTable_FileSetMultiError, or nil if none found.
func (m *ComputeTable_FileSet) ValidateAll() error {
	return m.validate(true)
}

func (m *ComputeTable_FileSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSlicePlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComputeTable_FileSetValidationError{
					field:  "SlicePlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComputeTable_FileSetValidationError{
					field:  "SlicePlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSlicePlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComputeTable_FileSetValidationError{
				field:  "SlicePlan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPreparedFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComputeTable_FileSetValidationError{
						field:  fmt.Sprintf("PreparedFiles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComputeTable_FileSetValidationError{
						field:  fmt.Sprintf("PreparedFiles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComputeTable_FileSetValidationError{
					field:  fmt.Sprintf("PreparedFiles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ComputeTable_FileSetMultiError(errors)
	}

	return nil
}

// ComputeTable_FileSetMultiError is an error wrapping multiple validation
// errors returned by ComputeTable_FileSet.ValidateAll() if the designated
// constraints aren't met.
type ComputeTable_FileSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComputeTable_FileSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComputeTable_FileSetMultiError) AllErrors() []error { return m }

// ComputeTable_FileSetValidationError is the validation error returned by
// ComputeTable_FileSet.Validate if the designated constraints aren't met.
type ComputeTable_FileSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComputeTable_FileSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComputeTable_FileSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComputeTable_FileSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComputeTable_FileSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComputeTable_FileSetValidationError) ErrorName() string {
	return "ComputeTable_FileSetValidationError"
}

// Error satisfies the builtin error interface
func (e ComputeTable_FileSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComputeTable_FileSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComputeTable_FileSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComputeTable_FileSetValidationError{}

// Validate checks the field values on ExecuteRequest_Limits with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecuteRequest_Limits) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteRequest_Limits with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecuteRequest_LimitsMultiError, or nil if none found.
func (m *ExecuteRequest_Limits) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteRequest_Limits) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreviewRows

	if len(errors) > 0 {
		return ExecuteRequest_LimitsMultiError(errors)
	}

	return nil
}

// ExecuteRequest_LimitsMultiError is an error wrapping multiple validation
// errors returned by ExecuteRequest_Limits.ValidateAll() if the designated
// constraints aren't met.
type ExecuteRequest_LimitsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteRequest_LimitsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteRequest_LimitsMultiError) AllErrors() []error { return m }

// ExecuteRequest_LimitsValidationError is the validation error returned by
// ExecuteRequest_Limits.Validate if the designated constraints aren't met.
type ExecuteRequest_LimitsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteRequest_LimitsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteRequest_LimitsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteRequest_LimitsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteRequest_LimitsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteRequest_LimitsValidationError) ErrorName() string {
	return "ExecuteRequest_LimitsValidationError"
}

// Error satisfies the builtin error interface
func (e ExecuteRequest_LimitsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteRequest_Limits.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteRequest_LimitsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteRequest_LimitsValidationError{}

// Validate checks the field values on ExecuteRequest_ComputeSnapshotConfig
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExecuteRequest_ComputeSnapshotConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteRequest_ComputeSnapshotConfig
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExecuteRequest_ComputeSnapshotConfigMultiError, or nil if none found.
func (m *ExecuteRequest_ComputeSnapshotConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteRequest_ComputeSnapshotConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OutputPrefix

	if all {
		switch v := interface{}(m.GetResumeFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequest_ComputeSnapshotConfigValidationError{
					field:  "ResumeFrom",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequest_ComputeSnapshotConfigValidationError{
					field:  "ResumeFrom",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResumeFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequest_ComputeSnapshotConfigValidationError{
				field:  "ResumeFrom",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExecuteRequest_ComputeSnapshotConfigMultiError(errors)
	}

	return nil
}

// ExecuteRequest_ComputeSnapshotConfigMultiError is an error wrapping multiple
// validation errors returned by
// ExecuteRequest_ComputeSnapshotConfig.ValidateAll() if the designated
// constraints aren't met.
type ExecuteRequest_ComputeSnapshotConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteRequest_ComputeSnapshotConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteRequest_ComputeSnapshotConfigMultiError) AllErrors() []error { return m }

// ExecuteRequest_ComputeSnapshotConfigValidationError is the validation error
// returned by ExecuteRequest_ComputeSnapshotConfig.Validate if the designated
// constraints aren't met.
type ExecuteRequest_ComputeSnapshotConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteRequest_ComputeSnapshotConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteRequest_ComputeSnapshotConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteRequest_ComputeSnapshotConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteRequest_ComputeSnapshotConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteRequest_ComputeSnapshotConfigValidationError) ErrorName() string {
	return "ExecuteRequest_ComputeSnapshotConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ExecuteRequest_ComputeSnapshotConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteRequest_ComputeSnapshotConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteRequest_ComputeSnapshotConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteRequest_ComputeSnapshotConfigValidationError{}

// Validate checks the field values on ExecuteRequest_OutputTo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecuteRequest_OutputTo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteRequest_OutputTo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecuteRequest_OutputToMultiError, or nil if none found.
func (m *ExecuteRequest_OutputTo) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteRequest_OutputTo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Destination.(type) {

	case *ExecuteRequest_OutputTo_ObjectStore:

		if all {
			switch v := interface{}(m.GetObjectStore()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteRequest_OutputToValidationError{
						field:  "ObjectStore",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteRequest_OutputToValidationError{
						field:  "ObjectStore",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectStore()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteRequest_OutputToValidationError{
					field:  "ObjectStore",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExecuteRequest_OutputTo_Redis:

		if all {
			switch v := interface{}(m.GetRedis()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteRequest_OutputToValidationError{
						field:  "Redis",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteRequest_OutputToValidationError{
						field:  "Redis",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRedis()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteRequest_OutputToValidationError{
					field:  "Redis",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExecuteRequest_OutputTo_Pulsar:

		if all {
			switch v := interface{}(m.GetPulsar()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteRequest_OutputToValidationError{
						field:  "Pulsar",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteRequest_OutputToValidationError{
						field:  "Pulsar",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPulsar()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteRequest_OutputToValidationError{
					field:  "Pulsar",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExecuteRequest_OutputToMultiError(errors)
	}

	return nil
}

// ExecuteRequest_OutputToMultiError is an error wrapping multiple validation
// errors returned by ExecuteRequest_OutputTo.ValidateAll() if the designated
// constraints aren't met.
type ExecuteRequest_OutputToMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteRequest_OutputToMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteRequest_OutputToMultiError) AllErrors() []error { return m }

// ExecuteRequest_OutputToValidationError is the validation error returned by
// ExecuteRequest_OutputTo.Validate if the designated constraints aren't met.
type ExecuteRequest_OutputToValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteRequest_OutputToValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteRequest_OutputToValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteRequest_OutputToValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteRequest_OutputToValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteRequest_OutputToValidationError) ErrorName() string {
	return "ExecuteRequest_OutputToValidationError"
}

// Error satisfies the builtin error interface
func (e ExecuteRequest_OutputToValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteRequest_OutputTo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteRequest_OutputToValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteRequest_OutputToValidationError{}

// Validate checks the field values on ExecuteResponse_Output with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecuteResponse_Output) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteResponse_Output with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecuteResponse_OutputMultiError, or nil if none found.
func (m *ExecuteResponse_Output) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteResponse_Output) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Output.(type) {

	case *ExecuteResponse_Output_Unspecified:

		if all {
			switch v := interface{}(m.GetUnspecified()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteResponse_OutputValidationError{
						field:  "Unspecified",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteResponse_OutputValidationError{
						field:  "Unspecified",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUnspecified()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteResponse_OutputValidationError{
					field:  "Unspecified",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExecuteResponse_Output_ObjectStore:

		if all {
			switch v := interface{}(m.GetObjectStore()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteResponse_OutputValidationError{
						field:  "ObjectStore",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteResponse_OutputValidationError{
						field:  "ObjectStore",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectStore()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteResponse_OutputValidationError{
					field:  "ObjectStore",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExecuteResponse_Output_Redis:

		if all {
			switch v := interface{}(m.GetRedis()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteResponse_OutputValidationError{
						field:  "Redis",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteResponse_OutputValidationError{
						field:  "Redis",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRedis()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteResponse_OutputValidationError{
					field:  "Redis",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExecuteResponse_Output_Pulsar:

		if all {
			switch v := interface{}(m.GetPulsar()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteResponse_OutputValidationError{
						field:  "Pulsar",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteResponse_OutputValidationError{
						field:  "Pulsar",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPulsar()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteResponse_OutputValidationError{
					field:  "Pulsar",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExecuteResponse_OutputMultiError(errors)
	}

	return nil
}

// ExecuteResponse_OutputMultiError is an error wrapping multiple validation
// errors returned by ExecuteResponse_Output.ValidateAll() if the designated
// constraints aren't met.
type ExecuteResponse_OutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteResponse_OutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteResponse_OutputMultiError) AllErrors() []error { return m }

// ExecuteResponse_OutputValidationError is the validation error returned by
// ExecuteResponse_Output.Validate if the designated constraints aren't met.
type ExecuteResponse_OutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteResponse_OutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteResponse_OutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteResponse_OutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteResponse_OutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteResponse_OutputValidationError) ErrorName() string {
	return "ExecuteResponse_OutputValidationError"
}

// Error satisfies the builtin error interface
func (e ExecuteResponse_OutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteResponse_Output.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteResponse_OutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteResponse_OutputValidationError{}

// Validate checks the field values on ExecuteResponse_ProgressInformation with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ExecuteResponse_ProgressInformation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteResponse_ProgressInformation
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExecuteResponse_ProgressInformationMultiError, or nil if none found.
func (m *ExecuteResponse_ProgressInformation) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteResponse_ProgressInformation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalInputRows

	// no validation rules for ProcessedInputRows

	// no validation rules for BufferedRows

	// no validation rules for ProcessedBufferedRows

	// no validation rules for MinEventTime

	// no validation rules for MaxEventTime

	// no validation rules for OutputTime

	// no validation rules for ProducedOutputRows

	if len(errors) > 0 {
		return ExecuteResponse_ProgressInformationMultiError(errors)
	}

	return nil
}

// ExecuteResponse_ProgressInformationMultiError is an error wrapping multiple
// validation errors returned by
// ExecuteResponse_ProgressInformation.ValidateAll() if the designated
// constraints aren't met.
type ExecuteResponse_ProgressInformationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteResponse_ProgressInformationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteResponse_ProgressInformationMultiError) AllErrors() []error { return m }

// ExecuteResponse_ProgressInformationValidationError is the validation error
// returned by ExecuteResponse_ProgressInformation.Validate if the designated
// constraints aren't met.
type ExecuteResponse_ProgressInformationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteResponse_ProgressInformationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteResponse_ProgressInformationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteResponse_ProgressInformationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteResponse_ProgressInformationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteResponse_ProgressInformationValidationError) ErrorName() string {
	return "ExecuteResponse_ProgressInformationValidationError"
}

// Error satisfies the builtin error interface
func (e ExecuteResponse_ProgressInformationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteResponse_ProgressInformation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteResponse_ProgressInformationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteResponse_ProgressInformationValidationError{}

// Validate checks the field values on ExecuteResponse_ComputeSnapshot with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecuteResponse_ComputeSnapshot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteResponse_ComputeSnapshot with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ExecuteResponse_ComputeSnapshotMultiError, or nil if none found.
func (m *ExecuteResponse_ComputeSnapshot) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteResponse_ComputeSnapshot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	if all {
		switch v := interface{}(m.GetMaxEventTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteResponse_ComputeSnapshotValidationError{
					field:  "MaxEventTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteResponse_ComputeSnapshotValidationError{
					field:  "MaxEventTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxEventTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteResponse_ComputeSnapshotValidationError{
				field:  "MaxEventTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlanHash()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteResponse_ComputeSnapshotValidationError{
					field:  "PlanHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteResponse_ComputeSnapshotValidationError{
					field:  "PlanHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlanHash()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteResponse_ComputeSnapshotValidationError{
				field:  "PlanHash",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SnapshotVersion

	if len(errors) > 0 {
		return ExecuteResponse_ComputeSnapshotMultiError(errors)
	}

	return nil
}

// ExecuteResponse_ComputeSnapshotMultiError is an error wrapping multiple
// validation errors returned by ExecuteResponse_ComputeSnapshot.ValidateAll()
// if the designated constraints aren't met.
type ExecuteResponse_ComputeSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteResponse_ComputeSnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteResponse_ComputeSnapshotMultiError) AllErrors() []error { return m }

// ExecuteResponse_ComputeSnapshotValidationError is the validation error
// returned by ExecuteResponse_ComputeSnapshot.Validate if the designated
// constraints aren't met.
type ExecuteResponse_ComputeSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteResponse_ComputeSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteResponse_ComputeSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteResponse_ComputeSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteResponse_ComputeSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteResponse_ComputeSnapshotValidationError) ErrorName() string {
	return "ExecuteResponse_ComputeSnapshotValidationError"
}

// Error satisfies the builtin error interface
func (e ExecuteResponse_ComputeSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteResponse_ComputeSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteResponse_ComputeSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteResponse_ComputeSnapshotValidationError{}
