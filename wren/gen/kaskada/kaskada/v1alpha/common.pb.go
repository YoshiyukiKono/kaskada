// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0-devel
// 	protoc        (unknown)
// source: kaskada/kaskada/v1alpha/common.proto

package kaskadav1alpha

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type FileType int32

const (
	// if unspecified, the engine will default to parquet
	// note: this behavior may change in the future
	FileType_FILE_TYPE_UNSPECIFIED FileType = 0
	FileType_FILE_TYPE_PARQUET     FileType = 1
	FileType_FILE_TYPE_CSV         FileType = 2
)

// Enum value maps for FileType.
var (
	FileType_name = map[int32]string{
		0: "FILE_TYPE_UNSPECIFIED",
		1: "FILE_TYPE_PARQUET",
		2: "FILE_TYPE_CSV",
	}
	FileType_value = map[string]int32{
		"FILE_TYPE_UNSPECIFIED": 0,
		"FILE_TYPE_PARQUET":     1,
		"FILE_TYPE_CSV":         2,
	}
)

func (x FileType) Enum() *FileType {
	p := new(FileType)
	*p = x
	return p
}

func (x FileType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FileType) Descriptor() protoreflect.EnumDescriptor {
	return file_kaskada_kaskada_v1alpha_common_proto_enumTypes[0].Descriptor()
}

func (FileType) Type() protoreflect.EnumType {
	return &file_kaskada_kaskada_v1alpha_common_proto_enumTypes[0]
}

func (x FileType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FileType.Descriptor instead.
func (FileType) EnumDescriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{0}
}

type PerEntityBehavior int32

const (
	PerEntityBehavior_PER_ENTITY_BEHAVIOR_UNSPECIFIED PerEntityBehavior = 0
	// (Default) Outputs all results for each entity.
	PerEntityBehavior_PER_ENTITY_BEHAVIOR_ALL PerEntityBehavior = 1
	// Outputs the final result for each entity.
	PerEntityBehavior_PER_ENTITY_BEHAVIOR_FINAL PerEntityBehavior = 2
	// Outputs the final results at a specific time for each entity.
	PerEntityBehavior_PER_ENTITY_BEHAVIOR_FINAL_AT_TIME PerEntityBehavior = 3
)

// Enum value maps for PerEntityBehavior.
var (
	PerEntityBehavior_name = map[int32]string{
		0: "PER_ENTITY_BEHAVIOR_UNSPECIFIED",
		1: "PER_ENTITY_BEHAVIOR_ALL",
		2: "PER_ENTITY_BEHAVIOR_FINAL",
		3: "PER_ENTITY_BEHAVIOR_FINAL_AT_TIME",
	}
	PerEntityBehavior_value = map[string]int32{
		"PER_ENTITY_BEHAVIOR_UNSPECIFIED":   0,
		"PER_ENTITY_BEHAVIOR_ALL":           1,
		"PER_ENTITY_BEHAVIOR_FINAL":         2,
		"PER_ENTITY_BEHAVIOR_FINAL_AT_TIME": 3,
	}
)

func (x PerEntityBehavior) Enum() *PerEntityBehavior {
	p := new(PerEntityBehavior)
	*p = x
	return p
}

func (x PerEntityBehavior) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PerEntityBehavior) Descriptor() protoreflect.EnumDescriptor {
	return file_kaskada_kaskada_v1alpha_common_proto_enumTypes[1].Descriptor()
}

func (PerEntityBehavior) Type() protoreflect.EnumType {
	return &file_kaskada_kaskada_v1alpha_common_proto_enumTypes[1]
}

func (x PerEntityBehavior) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PerEntityBehavior.Descriptor instead.
func (PerEntityBehavior) EnumDescriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{1}
}

// Configuration for a single source of data in a table.
type FilePath struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Path:
	//	*FilePath_ParquetPath
	//	*FilePath_CsvPath
	//	*FilePath_CsvData
	Path isFilePath_Path `protobuf_oneof:"path"`
}

func (x *FilePath) Reset() {
	*x = FilePath{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FilePath) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FilePath) ProtoMessage() {}

func (x *FilePath) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FilePath.ProtoReflect.Descriptor instead.
func (*FilePath) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{0}
}

func (m *FilePath) GetPath() isFilePath_Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (x *FilePath) GetParquetPath() string {
	if x, ok := x.GetPath().(*FilePath_ParquetPath); ok {
		return x.ParquetPath
	}
	return ""
}

func (x *FilePath) GetCsvPath() string {
	if x, ok := x.GetPath().(*FilePath_CsvPath); ok {
		return x.CsvPath
	}
	return ""
}

func (x *FilePath) GetCsvData() string {
	if x, ok := x.GetPath().(*FilePath_CsvData); ok {
		return x.CsvData
	}
	return ""
}

type isFilePath_Path interface {
	isFilePath_Path()
}

type FilePath_ParquetPath struct {
	// Path to a Parquet file to read for the table.
	ParquetPath string `protobuf:"bytes,1,opt,name=parquet_path,json=parquetPath,proto3,oneof"`
}

type FilePath_CsvPath struct {
	// Path to a CSV file to read for the table.
	CsvPath string `protobuf:"bytes,2,opt,name=csv_path,json=csvPath,proto3,oneof"`
}

type FilePath_CsvData struct {
	// CSV string to include in the table.
	//
	// This is analogous to a [`data:`
	// URI](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs).
	CsvData string `protobuf:"bytes,3,opt,name=csv_data,json=csvData,proto3,oneof"`
}

func (*FilePath_ParquetPath) isFilePath_Path() {}

func (*FilePath_CsvPath) isFilePath_Path() {}

func (*FilePath_CsvData) isFilePath_Path() {}

type FileInput struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	FileType FileType `protobuf:"varint,1,opt,name=file_type,json=fileType,proto3,enum=kaskada.kaskada.v1alpha.FileType" json:"file_type,omitempty"`
	// The URI of the parquet file to load into the table
	// Examples:
	// for azure:         https://myaccount.blob.core.windows.net/mycontainer/file.parquet
	// for gcs:           gs://bucket/prefix/file.parquet
	// for s3:            s3://bucket/prefix/file.parquet
	// for local storage: file://local_path/file.parquet
	Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
}

func (x *FileInput) Reset() {
	*x = FileInput{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FileInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileInput) ProtoMessage() {}

func (x *FileInput) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileInput.ProtoReflect.Descriptor instead.
func (*FileInput) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{1}
}

func (x *FileInput) GetFileType() FileType {
	if x != nil {
		return x.FileType
	}
	return FileType_FILE_TYPE_UNSPECIFIED
}

func (x *FileInput) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

type FileResults struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	FileType FileType `protobuf:"varint,1,opt,name=file_type,json=fileType,proto3,enum=kaskada.kaskada.v1alpha.FileType" json:"file_type,omitempty"`
	Paths    []string `protobuf:"bytes,2,rep,name=paths,proto3" json:"paths,omitempty"`
}

func (x *FileResults) Reset() {
	*x = FileResults{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FileResults) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileResults) ProtoMessage() {}

func (x *FileResults) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileResults.ProtoReflect.Descriptor instead.
func (*FileResults) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{2}
}

func (x *FileResults) GetFileType() FileType {
	if x != nil {
		return x.FileType
	}
	return FileType_FILE_TYPE_UNSPECIFIED
}

func (x *FileResults) GetPaths() []string {
	if x != nil {
		return x.Paths
	}
	return nil
}

type AsFiles struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	FileType FileType `protobuf:"varint,1,opt,name=file_type,json=fileType,proto3,enum=kaskada.kaskada.v1alpha.FileType" json:"file_type,omitempty"`
}

func (x *AsFiles) Reset() {
	*x = AsFiles{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AsFiles) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AsFiles) ProtoMessage() {}

func (x *AsFiles) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AsFiles.ProtoReflect.Descriptor instead.
func (*AsFiles) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{3}
}

func (x *AsFiles) GetFileType() FileType {
	if x != nil {
		return x.FileType
	}
	return FileType_FILE_TYPE_UNSPECIFIED
}

// General configuration for a table.
type TableConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The name of the table.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The unique uuid for the table.
	//
	// Equivalent to the `TableId` in Wren.
	Uuid string `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// The name of the time column within the table.
	TimeColumnName string `protobuf:"bytes,2,opt,name=time_column_name,json=timeColumnName,proto3" json:"time_column_name,omitempty"`
	// The name of the subsort column within the table.
	//
	// If the subsort column is not defined, a sequential subsort column will be created
	// starting at the hash of the file.
	SubsortColumnName *wrapperspb.StringValue `protobuf:"bytes,3,opt,name=subsort_column_name,json=subsortColumnName,proto3" json:"subsort_column_name,omitempty"`
	// The name of the grouping column within the table.
	//
	// TODO: Allow the grouping column to be optional, defaulting to unique IDs?
	GroupColumnName string `protobuf:"bytes,4,opt,name=group_column_name,json=groupColumnName,proto3" json:"group_column_name,omitempty"`
	// A name describing how the table is grouped.
	//
	// The type of the `group_column_name` should be the same for all tables with the same
	// `grouping`. This name is used for ensuring that different tables with the same type
	// of group key are compatible for implicit joining.
	//
	// If unspecified, this will default to a unique name (the name of the table). This
	// will require explicit joins.
	//p
	// TODO: Consider instead defaulting to a name derived from the type of the group
	// key. This would default to allowing implicit grouping amongst tables.
	Grouping string `protobuf:"bytes,5,opt,name=grouping,proto3" json:"grouping,omitempty"`
}

func (x *TableConfig) Reset() {
	*x = TableConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TableConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TableConfig) ProtoMessage() {}

func (x *TableConfig) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TableConfig.ProtoReflect.Descriptor instead.
func (*TableConfig) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{4}
}

func (x *TableConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TableConfig) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

func (x *TableConfig) GetTimeColumnName() string {
	if x != nil {
		return x.TimeColumnName
	}
	return ""
}

func (x *TableConfig) GetSubsortColumnName() *wrapperspb.StringValue {
	if x != nil {
		return x.SubsortColumnName
	}
	return nil
}

func (x *TableConfig) GetGroupColumnName() string {
	if x != nil {
		return x.GroupColumnName
	}
	return ""
}

func (x *TableConfig) GetGrouping() string {
	if x != nil {
		return x.Grouping
	}
	return ""
}

type TableMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The schema of the table.
	Schema *Schema `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	// The number of files in this table.
	FileCount int64 `protobuf:"varint,2,opt,name=file_count,json=fileCount,proto3" json:"file_count,omitempty"`
}

func (x *TableMetadata) Reset() {
	*x = TableMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TableMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TableMetadata) ProtoMessage() {}

func (x *TableMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TableMetadata.ProtoReflect.Descriptor instead.
func (*TableMetadata) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{5}
}

func (x *TableMetadata) GetSchema() *Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

func (x *TableMetadata) GetFileCount() int64 {
	if x != nil {
		return x.FileCount
	}
	return 0
}

type PreparedFile struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The path to the prepared parquet file. S3 paths will be prefixed with s3://
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// The minimum event time in the file
	//
	// As the file is sorted by time, this should be the first row's time.
	MinEventTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=min_event_time,json=minEventTime,proto3" json:"min_event_time,omitempty"`
	// The maximum event time in the file
	//
	// As the file is sorted by time, this should be the last row's time.
	MaxEventTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=max_event_time,json=maxEventTime,proto3" json:"max_event_time,omitempty"`
	// Number of rows in the prepared file.
	NumRows int64 `protobuf:"varint,4,opt,name=num_rows,json=numRows,proto3" json:"num_rows,omitempty"`
	// The path to metadata mapping the entity key hash to the entity key
	MetadataPath string `protobuf:"bytes,5,opt,name=metadata_path,json=metadataPath,proto3" json:"metadata_path,omitempty"`
}

func (x *PreparedFile) Reset() {
	*x = PreparedFile{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PreparedFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PreparedFile) ProtoMessage() {}

func (x *PreparedFile) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PreparedFile.ProtoReflect.Descriptor instead.
func (*PreparedFile) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{6}
}

func (x *PreparedFile) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *PreparedFile) GetMinEventTime() *timestamppb.Timestamp {
	if x != nil {
		return x.MinEventTime
	}
	return nil
}

func (x *PreparedFile) GetMaxEventTime() *timestamppb.Timestamp {
	if x != nil {
		return x.MaxEventTime
	}
	return nil
}

func (x *PreparedFile) GetNumRows() int64 {
	if x != nil {
		return x.NumRows
	}
	return 0
}

func (x *PreparedFile) GetMetadataPath() string {
	if x != nil {
		return x.MetadataPath
	}
	return ""
}

// used internally in wren
type PreparedFileMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// the path of the original raw file that was prepared
	RawFilePath string `protobuf:"bytes,1,opt,name=raw_file_path,json=rawFilePath,proto3" json:"raw_file_path,omitempty"`
	// the prepared files
	PreparedFiles []*PreparedFile `protobuf:"bytes,2,rep,name=prepared_files,json=preparedFiles,proto3" json:"prepared_files,omitempty"`
}

func (x *PreparedFileMetadata) Reset() {
	*x = PreparedFileMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PreparedFileMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PreparedFileMetadata) ProtoMessage() {}

func (x *PreparedFileMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PreparedFileMetadata.ProtoReflect.Descriptor instead.
func (*PreparedFileMetadata) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{7}
}

func (x *PreparedFileMetadata) GetRawFilePath() string {
	if x != nil {
		return x.RawFilePath
	}
	return ""
}

func (x *PreparedFileMetadata) GetPreparedFiles() []*PreparedFile {
	if x != nil {
		return x.PreparedFiles
	}
	return nil
}

// The plan for how to slice the data.
//
// The internal representation of a slice plan is for communication between Sparrow and Wren
// and is decoupled from the user representation of slices to allow evolution and inferring
// slices / filtering beyond what the user specifies.  e.g. if the user says "10% of entities"
// and the query was Table1 | when($input.x > 10) | ... the plan may be "10% of entities and
// filtered to inputs with x > 10".
//
// Currently, the plan supports percentage of the data to operate on and will filter the
// entity key appropriately.
//
// In the future, we will want to support additional methods of slicing such as partitioning,
// filtering, etc.
type SlicePlan struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The name of the table to be sliced.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// Each slice plan has a specific method of slicing.
	//
	// As the slices evolve, additional slices will be added.
	//
	// Types that are assignable to Slice:
	//	*SlicePlan_Percent
	//	*SlicePlan_EntityKeys
	Slice isSlicePlan_Slice `protobuf_oneof:"slice"`
}

func (x *SlicePlan) Reset() {
	*x = SlicePlan{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SlicePlan) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SlicePlan) ProtoMessage() {}

func (x *SlicePlan) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SlicePlan.ProtoReflect.Descriptor instead.
func (*SlicePlan) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{8}
}

func (x *SlicePlan) GetTableName() string {
	if x != nil {
		return x.TableName
	}
	return ""
}

func (m *SlicePlan) GetSlice() isSlicePlan_Slice {
	if m != nil {
		return m.Slice
	}
	return nil
}

func (x *SlicePlan) GetPercent() *SlicePlan_PercentSlice {
	if x, ok := x.GetSlice().(*SlicePlan_Percent); ok {
		return x.Percent
	}
	return nil
}

func (x *SlicePlan) GetEntityKeys() *SlicePlan_EntityKeysSlice {
	if x, ok := x.GetSlice().(*SlicePlan_EntityKeys); ok {
		return x.EntityKeys
	}
	return nil
}

type isSlicePlan_Slice interface {
	isSlicePlan_Slice()
}

type SlicePlan_Percent struct {
	Percent *SlicePlan_PercentSlice `protobuf:"bytes,2,opt,name=percent,proto3,oneof"`
}

type SlicePlan_EntityKeys struct {
	EntityKeys *SlicePlan_EntityKeysSlice `protobuf:"bytes,3,opt,name=entity_keys,json=entityKeys,proto3,oneof"`
}

func (*SlicePlan_Percent) isSlicePlan_Slice() {}

func (*SlicePlan_EntityKeys) isSlicePlan_Slice() {}

// Represents a 128-bit UUID as a pair of u64.
type Uuid struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	High uint64 `protobuf:"varint,1,opt,name=high,proto3" json:"high,omitempty"`
	Low  uint64 `protobuf:"varint,2,opt,name=low,proto3" json:"low,omitempty"`
}

func (x *Uuid) Reset() {
	*x = Uuid{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Uuid) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Uuid) ProtoMessage() {}

func (x *Uuid) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Uuid.ProtoReflect.Descriptor instead.
func (*Uuid) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{9}
}

func (x *Uuid) GetHigh() uint64 {
	if x != nil {
		return x.High
	}
	return 0
}

func (x *Uuid) GetLow() uint64 {
	if x != nil {
		return x.Low
	}
	return 0
}

// A shared request populated by the user defining how to slice the data
//
// Used in data preparation and eventually in materializations
type SliceRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Slice:
	//	*SliceRequest_Percent
	//	*SliceRequest_EntityKeys
	Slice isSliceRequest_Slice `protobuf_oneof:"slice"`
}

func (x *SliceRequest) Reset() {
	*x = SliceRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SliceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SliceRequest) ProtoMessage() {}

func (x *SliceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SliceRequest.ProtoReflect.Descriptor instead.
func (*SliceRequest) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{10}
}

func (m *SliceRequest) GetSlice() isSliceRequest_Slice {
	if m != nil {
		return m.Slice
	}
	return nil
}

func (x *SliceRequest) GetPercent() *SliceRequest_PercentSlice {
	if x, ok := x.GetSlice().(*SliceRequest_Percent); ok {
		return x.Percent
	}
	return nil
}

func (x *SliceRequest) GetEntityKeys() *SliceRequest_EntityKeysSlice {
	if x, ok := x.GetSlice().(*SliceRequest_EntityKeys); ok {
		return x.EntityKeys
	}
	return nil
}

type isSliceRequest_Slice interface {
	isSliceRequest_Slice()
}

type SliceRequest_Percent struct {
	Percent *SliceRequest_PercentSlice `protobuf:"bytes,1,opt,name=percent,proto3,oneof"`
}

type SliceRequest_EntityKeys struct {
	EntityKeys *SliceRequest_EntityKeysSlice `protobuf:"bytes,2,opt,name=entity_keys,json=entityKeys,proto3,oneof"`
}

func (*SliceRequest_Percent) isSliceRequest_Slice() {}

func (*SliceRequest_EntityKeys) isSliceRequest_Slice() {}

type Analysis struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Names that were missing in the query.
	//
	// These are formulas (views) and tables referenced directly or
	// indirectly by the query which were not provided in the request.
	// An indirect reference occurs when the query references a
	// provided formula which references formulas or tables.
	//
	// If this is non-empty, the FenlDiagnostics should include
	// corresponding "missing name" errors
	MissingNames []string `protobuf:"bytes,1,rep,name=missing_names,json=missingNames,proto3" json:"missing_names,omitempty"`
	// Fenl Diagnostics -- warnings and errors derived from the query.
	FenlDiagnostics *FenlDiagnostics `protobuf:"bytes,2,opt,name=fenl_diagnostics,json=fenlDiagnostics,proto3" json:"fenl_diagnostics,omitempty"`
	// The executable state of the query. If false, there could be an issue executing the query
	// otherwise the query is executable.
	CanExecute bool `protobuf:"varint,3,opt,name=can_execute,json=canExecute,proto3" json:"can_execute,omitempty"`
	// Top level names that are directly referenced by the query.
	//
	// These are formulas (views) and tables referenced by the query.
	//
	// This includes all free names, including those which were "missing".
	//
	// This may be empty if the query or formulas failed to parse.
	FreeNames []string `protobuf:"bytes,4,rep,name=free_names,json=freeNames,proto3" json:"free_names,omitempty"`
}

func (x *Analysis) Reset() {
	*x = Analysis{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Analysis) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Analysis) ProtoMessage() {}

func (x *Analysis) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Analysis.ProtoReflect.Descriptor instead.
func (*Analysis) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{11}
}

func (x *Analysis) GetMissingNames() []string {
	if x != nil {
		return x.MissingNames
	}
	return nil
}

func (x *Analysis) GetFenlDiagnostics() *FenlDiagnostics {
	if x != nil {
		return x.FenlDiagnostics
	}
	return nil
}

func (x *Analysis) GetCanExecute() bool {
	if x != nil {
		return x.CanExecute
	}
	return false
}

func (x *Analysis) GetFreeNames() []string {
	if x != nil {
		return x.FreeNames
	}
	return nil
}

type RequestDetails struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// a opaque string that can help identify this request when debugging an
	// issue.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (x *RequestDetails) Reset() {
	*x = RequestDetails{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RequestDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestDetails) ProtoMessage() {}

func (x *RequestDetails) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestDetails.ProtoReflect.Descriptor instead.
func (*RequestDetails) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{12}
}

func (x *RequestDetails) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

// A percent slice will slice a percentage of data and filter by the entity key.
type SlicePlan_PercentSlice struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Percent of entities to include in the slice.
	Percent float64 `protobuf:"fixed64,1,opt,name=percent,proto3" json:"percent,omitempty"`
}

func (x *SlicePlan_PercentSlice) Reset() {
	*x = SlicePlan_PercentSlice{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SlicePlan_PercentSlice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SlicePlan_PercentSlice) ProtoMessage() {}

func (x *SlicePlan_PercentSlice) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SlicePlan_PercentSlice.ProtoReflect.Descriptor instead.
func (*SlicePlan_PercentSlice) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{8, 0}
}

func (x *SlicePlan_PercentSlice) GetPercent() float64 {
	if x != nil {
		return x.Percent
	}
	return 0
}

// An entity key slice will filter the data by the entity keys
type SlicePlan_EntityKeysSlice struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	EntityKeys []string `protobuf:"bytes,1,rep,name=entity_keys,json=entityKeys,proto3" json:"entity_keys,omitempty"`
}

func (x *SlicePlan_EntityKeysSlice) Reset() {
	*x = SlicePlan_EntityKeysSlice{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SlicePlan_EntityKeysSlice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SlicePlan_EntityKeysSlice) ProtoMessage() {}

func (x *SlicePlan_EntityKeysSlice) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SlicePlan_EntityKeysSlice.ProtoReflect.Descriptor instead.
func (*SlicePlan_EntityKeysSlice) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{8, 1}
}

func (x *SlicePlan_EntityKeysSlice) GetEntityKeys() []string {
	if x != nil {
		return x.EntityKeys
	}
	return nil
}

type SliceRequest_PercentSlice struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The percentage of entities (not overall data) to slice the data
	Percent float64 `protobuf:"fixed64,1,opt,name=percent,proto3" json:"percent,omitempty"`
}

func (x *SliceRequest_PercentSlice) Reset() {
	*x = SliceRequest_PercentSlice{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SliceRequest_PercentSlice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SliceRequest_PercentSlice) ProtoMessage() {}

func (x *SliceRequest_PercentSlice) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SliceRequest_PercentSlice.ProtoReflect.Descriptor instead.
func (*SliceRequest_PercentSlice) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{10, 0}
}

func (x *SliceRequest_PercentSlice) GetPercent() float64 {
	if x != nil {
		return x.Percent
	}
	return 0
}

type SliceRequest_EntityKeysSlice struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The entity keys to slice the data.
	//
	// Each entity key is the string encoding of the entity key.
	// For string keys, the entity key is the provided string.
	// For numeric keys, such as i64, this is the string representation.
	//   e.g. Numeric Entity Key: 15 -> "15"
	EntityKeys []string `protobuf:"bytes,2,rep,name=entity_keys,json=entityKeys,proto3" json:"entity_keys,omitempty"`
}

func (x *SliceRequest_EntityKeysSlice) Reset() {
	*x = SliceRequest_EntityKeysSlice{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SliceRequest_EntityKeysSlice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SliceRequest_EntityKeysSlice) ProtoMessage() {}

func (x *SliceRequest_EntityKeysSlice) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_common_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SliceRequest_EntityKeysSlice.ProtoReflect.Descriptor instead.
func (*SliceRequest_EntityKeysSlice) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP(), []int{10, 1}
}

func (x *SliceRequest_EntityKeysSlice) GetEntityKeys() []string {
	if x != nil {
		return x.EntityKeys
	}
	return nil
}

var File_kaskada_kaskada_v1alpha_common_proto protoreflect.FileDescriptor

var file_kaskada_kaskada_v1alpha_common_proto_rawDesc = []byte{
	0x0a, 0x24, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2f, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64,
	0x61, 0x2f, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x17, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e,
	0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x1a,
	0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
	0x66, 0x2f, 0x77, 0x72, 0x61, 0x70, 0x70, 0x65, 0x72, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2f, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64,
	0x61, 0x2f, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2f, 0x66, 0x65, 0x6e, 0x6c, 0x5f, 0x64,
	0x69, 0x61, 0x67, 0x6e, 0x6f, 0x73, 0x74, 0x69, 0x63, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x24, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2f, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64,
	0x61, 0x2f, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x71, 0x0a, 0x08, 0x46, 0x69, 0x6c, 0x65, 0x50, 0x61,
	0x74, 0x68, 0x12, 0x23, 0x0a, 0x0c, 0x70, 0x61, 0x72, 0x71, 0x75, 0x65, 0x74, 0x5f, 0x70, 0x61,
	0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x0b, 0x70, 0x61, 0x72, 0x71,
	0x75, 0x65, 0x74, 0x50, 0x61, 0x74, 0x68, 0x12, 0x1b, 0x0a, 0x08, 0x63, 0x73, 0x76, 0x5f, 0x70,
	0x61, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x07, 0x63, 0x73, 0x76,
	0x50, 0x61, 0x74, 0x68, 0x12, 0x1b, 0x0a, 0x08, 0x63, 0x73, 0x76, 0x5f, 0x64, 0x61, 0x74, 0x61,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x07, 0x63, 0x73, 0x76, 0x44, 0x61, 0x74,
	0x61, 0x42, 0x06, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x22, 0x5d, 0x0a, 0x09, 0x46, 0x69, 0x6c,
	0x65, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x12, 0x3e, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x74,
	0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x52, 0x08, 0x66, 0x69,
	0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x69, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x69, 0x22, 0x63, 0x0a, 0x0b, 0x46, 0x69, 0x6c, 0x65,
	0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x12, 0x3e, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f,
	0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x6b, 0x61, 0x73,
	0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x52, 0x08, 0x66,
	0x69, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x70, 0x61, 0x74, 0x68, 0x73,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x70, 0x61, 0x74, 0x68, 0x73, 0x22, 0x49, 0x0a,
	0x07, 0x41, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x3e, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65,
	0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x6b, 0x61,
	0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x52, 0x08,
	0x66, 0x69, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x22, 0xf5, 0x01, 0x0a, 0x0b, 0x54, 0x61, 0x62,
	0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04,
	0x75, 0x75, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x75, 0x69, 0x64,
	0x12, 0x28, 0x0a, 0x10, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x5f,
	0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x69, 0x6d, 0x65,
	0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x4c, 0x0a, 0x13, 0x73, 0x75,
	0x62, 0x73, 0x6f, 0x72, 0x74, 0x5f, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x5f, 0x6e, 0x61, 0x6d,
	0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67,
	0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x11, 0x73, 0x75, 0x62, 0x73, 0x6f, 0x72, 0x74, 0x43, 0x6f,
	0x6c, 0x75, 0x6d, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x2a, 0x0a, 0x11, 0x67, 0x72, 0x6f, 0x75,
	0x70, 0x5f, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0f, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e,
	0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x69, 0x6e, 0x67,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x69, 0x6e, 0x67,
	0x22, 0x67, 0x0a, 0x0d, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
	0x61, 0x12, 0x37, 0x0a, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1f, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x53, 0x63, 0x68, 0x65,
	0x6d, 0x61, 0x52, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x1d, 0x0a, 0x0a, 0x66, 0x69,
	0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09,
	0x66, 0x69, 0x6c, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0xe6, 0x01, 0x0a, 0x0c, 0x50, 0x72,
	0x65, 0x70, 0x61, 0x72, 0x65, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61,
	0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x70, 0x61, 0x74, 0x68, 0x12, 0x40,
	0x0a, 0x0e, 0x6d, 0x69, 0x6e, 0x5f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
	0x6d, 0x70, 0x52, 0x0c, 0x6d, 0x69, 0x6e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x69, 0x6d, 0x65,
	0x12, 0x40, 0x0a, 0x0e, 0x6d, 0x61, 0x78, 0x5f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x69,
	0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x52, 0x0c, 0x6d, 0x61, 0x78, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x69,
	0x6d, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x75, 0x6d, 0x5f, 0x72, 0x6f, 0x77, 0x73, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x07, 0x6e, 0x75, 0x6d, 0x52, 0x6f, 0x77, 0x73, 0x12, 0x23, 0x0a,
	0x0d, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x50, 0x61,
	0x74, 0x68, 0x22, 0x88, 0x01, 0x0a, 0x14, 0x50, 0x72, 0x65, 0x70, 0x61, 0x72, 0x65, 0x64, 0x46,
	0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x22, 0x0a, 0x0d, 0x72,
	0x61, 0x77, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0b, 0x72, 0x61, 0x77, 0x46, 0x69, 0x6c, 0x65, 0x50, 0x61, 0x74, 0x68, 0x12,
	0x4c, 0x0a, 0x0e, 0x70, 0x72, 0x65, 0x70, 0x61, 0x72, 0x65, 0x64, 0x5f, 0x66, 0x69, 0x6c, 0x65,
	0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64,
	0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68,
	0x61, 0x2e, 0x50, 0x72, 0x65, 0x70, 0x61, 0x72, 0x65, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x52, 0x0d,
	0x70, 0x72, 0x65, 0x70, 0x61, 0x72, 0x65, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x22, 0xb5, 0x02,
	0x0a, 0x09, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x6c, 0x61, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x74,
	0x61, 0x62, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x09, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x4b, 0x0a, 0x07, 0x70, 0x65,
	0x72, 0x63, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6b, 0x61,
	0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x6c, 0x61, 0x6e, 0x2e,
	0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x48, 0x00, 0x52, 0x07,
	0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x12, 0x55, 0x0a, 0x0b, 0x65, 0x6e, 0x74, 0x69, 0x74,
	0x79, 0x5f, 0x6b, 0x65, 0x79, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x6b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x6c, 0x61, 0x6e,
	0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x73, 0x53, 0x6c, 0x69, 0x63, 0x65,
	0x48, 0x00, 0x52, 0x0a, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x73, 0x1a, 0x28,
	0x0a, 0x0c, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x12, 0x18,
	0x0a, 0x07, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52,
	0x07, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x1a, 0x32, 0x0a, 0x0f, 0x45, 0x6e, 0x74, 0x69,
	0x74, 0x79, 0x4b, 0x65, 0x79, 0x73, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x65,
	0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x6b, 0x65, 0x79, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09,
	0x52, 0x0a, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x73, 0x42, 0x07, 0x0a, 0x05,
	0x73, 0x6c, 0x69, 0x63, 0x65, 0x22, 0x2c, 0x0a, 0x04, 0x55, 0x75, 0x69, 0x64, 0x12, 0x12, 0x0a,
	0x04, 0x68, 0x69, 0x67, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x04, 0x68, 0x69, 0x67,
	0x68, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x6f, 0x77, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x03,
	0x6c, 0x6f, 0x77, 0x22, 0x9f, 0x02, 0x0a, 0x0c, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x4e, 0x0a, 0x07, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e,
	0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e,
	0x53, 0x6c, 0x69, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x50, 0x65, 0x72,
	0x63, 0x65, 0x6e, 0x74, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x48, 0x00, 0x52, 0x07, 0x70, 0x65, 0x72,
	0x63, 0x65, 0x6e, 0x74, 0x12, 0x58, 0x0a, 0x0b, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x6b,
	0x65, 0x79, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x2e, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x73, 0x53, 0x6c, 0x69, 0x63, 0x65,
	0x48, 0x00, 0x52, 0x0a, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x73, 0x1a, 0x28,
	0x0a, 0x0c, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x12, 0x18,
	0x0a, 0x07, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52,
	0x07, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x1a, 0x32, 0x0a, 0x0f, 0x45, 0x6e, 0x74, 0x69,
	0x74, 0x79, 0x4b, 0x65, 0x79, 0x73, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x65,
	0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x6b, 0x65, 0x79, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09,
	0x52, 0x0a, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x73, 0x42, 0x07, 0x0a, 0x05,
	0x73, 0x6c, 0x69, 0x63, 0x65, 0x22, 0xc4, 0x01, 0x0a, 0x08, 0x41, 0x6e, 0x61, 0x6c, 0x79, 0x73,
	0x69, 0x73, 0x12, 0x23, 0x0a, 0x0d, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x5f, 0x6e, 0x61,
	0x6d, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x6d, 0x69, 0x73, 0x73, 0x69,
	0x6e, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x12, 0x53, 0x0a, 0x10, 0x66, 0x65, 0x6e, 0x6c, 0x5f,
	0x64, 0x69, 0x61, 0x67, 0x6e, 0x6f, 0x73, 0x74, 0x69, 0x63, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x28, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x46, 0x65, 0x6e, 0x6c,
	0x44, 0x69, 0x61, 0x67, 0x6e, 0x6f, 0x73, 0x74, 0x69, 0x63, 0x73, 0x52, 0x0f, 0x66, 0x65, 0x6e,
	0x6c, 0x44, 0x69, 0x61, 0x67, 0x6e, 0x6f, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x1f, 0x0a, 0x0b,
	0x63, 0x61, 0x6e, 0x5f, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x0a, 0x63, 0x61, 0x6e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x12, 0x1d, 0x0a,
	0x0a, 0x66, 0x72, 0x65, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28,
	0x09, 0x52, 0x09, 0x66, 0x72, 0x65, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x22, 0x2f, 0x0a, 0x0e,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x12, 0x1d,
	0x0a, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x2a, 0x4f, 0x0a,
	0x08, 0x46, 0x69, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x19, 0x0a, 0x15, 0x46, 0x49, 0x4c,
	0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49,
	0x45, 0x44, 0x10, 0x00, 0x12, 0x15, 0x0a, 0x11, 0x46, 0x49, 0x4c, 0x45, 0x5f, 0x54, 0x59, 0x50,
	0x45, 0x5f, 0x50, 0x41, 0x52, 0x51, 0x55, 0x45, 0x54, 0x10, 0x01, 0x12, 0x11, 0x0a, 0x0d, 0x46,
	0x49, 0x4c, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x43, 0x53, 0x56, 0x10, 0x02, 0x2a, 0x9b,
	0x01, 0x0a, 0x11, 0x50, 0x65, 0x72, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x42, 0x65, 0x68, 0x61,
	0x76, 0x69, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x1f, 0x50, 0x45, 0x52, 0x5f, 0x45, 0x4e, 0x54, 0x49,
	0x54, 0x59, 0x5f, 0x42, 0x45, 0x48, 0x41, 0x56, 0x49, 0x4f, 0x52, 0x5f, 0x55, 0x4e, 0x53, 0x50,
	0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1b, 0x0a, 0x17, 0x50, 0x45, 0x52,
	0x5f, 0x45, 0x4e, 0x54, 0x49, 0x54, 0x59, 0x5f, 0x42, 0x45, 0x48, 0x41, 0x56, 0x49, 0x4f, 0x52,
	0x5f, 0x41, 0x4c, 0x4c, 0x10, 0x01, 0x12, 0x1d, 0x0a, 0x19, 0x50, 0x45, 0x52, 0x5f, 0x45, 0x4e,
	0x54, 0x49, 0x54, 0x59, 0x5f, 0x42, 0x45, 0x48, 0x41, 0x56, 0x49, 0x4f, 0x52, 0x5f, 0x46, 0x49,
	0x4e, 0x41, 0x4c, 0x10, 0x02, 0x12, 0x25, 0x0a, 0x21, 0x50, 0x45, 0x52, 0x5f, 0x45, 0x4e, 0x54,
	0x49, 0x54, 0x59, 0x5f, 0x42, 0x45, 0x48, 0x41, 0x56, 0x49, 0x4f, 0x52, 0x5f, 0x46, 0x49, 0x4e,
	0x41, 0x4c, 0x5f, 0x41, 0x54, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x10, 0x03, 0x42, 0xf7, 0x01, 0x0a,
	0x1b, 0x63, 0x6f, 0x6d, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73,
	0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x42, 0x0b, 0x43, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x4d, 0x67, 0x69, 0x74,
	0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2f,
	0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2d, 0x61, 0x69, 0x2f, 0x77, 0x72, 0x65, 0x6e, 0x2f,
	0x67, 0x65, 0x6e, 0x2f, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2f, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2f, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x3b, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0xa2, 0x02, 0x03, 0x4b, 0x4b, 0x58,
	0xaa, 0x02, 0x17, 0x4b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x4b, 0x61, 0x73, 0x6b, 0x61,
	0x64, 0x61, 0x2e, 0x56, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0xca, 0x02, 0x17, 0x4b, 0x61, 0x73,
	0x6b, 0x61, 0x64, 0x61, 0x5c, 0x4b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x5c, 0x56, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0xe2, 0x02, 0x23, 0x4b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x5c, 0x4b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x5c, 0x56, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x5c, 0x47,
	0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x19, 0x4b, 0x61, 0x73,
	0x6b, 0x61, 0x64, 0x61, 0x3a, 0x3a, 0x4b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x3a, 0x3a, 0x56,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_kaskada_kaskada_v1alpha_common_proto_rawDescOnce sync.Once
	file_kaskada_kaskada_v1alpha_common_proto_rawDescData = file_kaskada_kaskada_v1alpha_common_proto_rawDesc
)

func file_kaskada_kaskada_v1alpha_common_proto_rawDescGZIP() []byte {
	file_kaskada_kaskada_v1alpha_common_proto_rawDescOnce.Do(func() {
		file_kaskada_kaskada_v1alpha_common_proto_rawDescData = protoimpl.X.CompressGZIP(file_kaskada_kaskada_v1alpha_common_proto_rawDescData)
	})
	return file_kaskada_kaskada_v1alpha_common_proto_rawDescData
}

var file_kaskada_kaskada_v1alpha_common_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_kaskada_kaskada_v1alpha_common_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_kaskada_kaskada_v1alpha_common_proto_goTypes = []interface{}{
	(FileType)(0),                        // 0: kaskada.kaskada.v1alpha.FileType
	(PerEntityBehavior)(0),               // 1: kaskada.kaskada.v1alpha.PerEntityBehavior
	(*FilePath)(nil),                     // 2: kaskada.kaskada.v1alpha.FilePath
	(*FileInput)(nil),                    // 3: kaskada.kaskada.v1alpha.FileInput
	(*FileResults)(nil),                  // 4: kaskada.kaskada.v1alpha.FileResults
	(*AsFiles)(nil),                      // 5: kaskada.kaskada.v1alpha.AsFiles
	(*TableConfig)(nil),                  // 6: kaskada.kaskada.v1alpha.TableConfig
	(*TableMetadata)(nil),                // 7: kaskada.kaskada.v1alpha.TableMetadata
	(*PreparedFile)(nil),                 // 8: kaskada.kaskada.v1alpha.PreparedFile
	(*PreparedFileMetadata)(nil),         // 9: kaskada.kaskada.v1alpha.PreparedFileMetadata
	(*SlicePlan)(nil),                    // 10: kaskada.kaskada.v1alpha.SlicePlan
	(*Uuid)(nil),                         // 11: kaskada.kaskada.v1alpha.Uuid
	(*SliceRequest)(nil),                 // 12: kaskada.kaskada.v1alpha.SliceRequest
	(*Analysis)(nil),                     // 13: kaskada.kaskada.v1alpha.Analysis
	(*RequestDetails)(nil),               // 14: kaskada.kaskada.v1alpha.RequestDetails
	(*SlicePlan_PercentSlice)(nil),       // 15: kaskada.kaskada.v1alpha.SlicePlan.PercentSlice
	(*SlicePlan_EntityKeysSlice)(nil),    // 16: kaskada.kaskada.v1alpha.SlicePlan.EntityKeysSlice
	(*SliceRequest_PercentSlice)(nil),    // 17: kaskada.kaskada.v1alpha.SliceRequest.PercentSlice
	(*SliceRequest_EntityKeysSlice)(nil), // 18: kaskada.kaskada.v1alpha.SliceRequest.EntityKeysSlice
	(*wrapperspb.StringValue)(nil),       // 19: google.protobuf.StringValue
	(*Schema)(nil),                       // 20: kaskada.kaskada.v1alpha.Schema
	(*timestamppb.Timestamp)(nil),        // 21: google.protobuf.Timestamp
	(*FenlDiagnostics)(nil),              // 22: kaskada.kaskada.v1alpha.FenlDiagnostics
}
var file_kaskada_kaskada_v1alpha_common_proto_depIdxs = []int32{
	0,  // 0: kaskada.kaskada.v1alpha.FileInput.file_type:type_name -> kaskada.kaskada.v1alpha.FileType
	0,  // 1: kaskada.kaskada.v1alpha.FileResults.file_type:type_name -> kaskada.kaskada.v1alpha.FileType
	0,  // 2: kaskada.kaskada.v1alpha.AsFiles.file_type:type_name -> kaskada.kaskada.v1alpha.FileType
	19, // 3: kaskada.kaskada.v1alpha.TableConfig.subsort_column_name:type_name -> google.protobuf.StringValue
	20, // 4: kaskada.kaskada.v1alpha.TableMetadata.schema:type_name -> kaskada.kaskada.v1alpha.Schema
	21, // 5: kaskada.kaskada.v1alpha.PreparedFile.min_event_time:type_name -> google.protobuf.Timestamp
	21, // 6: kaskada.kaskada.v1alpha.PreparedFile.max_event_time:type_name -> google.protobuf.Timestamp
	8,  // 7: kaskada.kaskada.v1alpha.PreparedFileMetadata.prepared_files:type_name -> kaskada.kaskada.v1alpha.PreparedFile
	15, // 8: kaskada.kaskada.v1alpha.SlicePlan.percent:type_name -> kaskada.kaskada.v1alpha.SlicePlan.PercentSlice
	16, // 9: kaskada.kaskada.v1alpha.SlicePlan.entity_keys:type_name -> kaskada.kaskada.v1alpha.SlicePlan.EntityKeysSlice
	17, // 10: kaskada.kaskada.v1alpha.SliceRequest.percent:type_name -> kaskada.kaskada.v1alpha.SliceRequest.PercentSlice
	18, // 11: kaskada.kaskada.v1alpha.SliceRequest.entity_keys:type_name -> kaskada.kaskada.v1alpha.SliceRequest.EntityKeysSlice
	22, // 12: kaskada.kaskada.v1alpha.Analysis.fenl_diagnostics:type_name -> kaskada.kaskada.v1alpha.FenlDiagnostics
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_kaskada_kaskada_v1alpha_common_proto_init() }
func file_kaskada_kaskada_v1alpha_common_proto_init() {
	if File_kaskada_kaskada_v1alpha_common_proto != nil {
		return
	}
	file_kaskada_kaskada_v1alpha_fenl_diagnostics_proto_init()
	file_kaskada_kaskada_v1alpha_schema_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FilePath); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FileInput); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FileResults); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AsFiles); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TableConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TableMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PreparedFile); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PreparedFileMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SlicePlan); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Uuid); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SliceRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Analysis); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RequestDetails); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SlicePlan_PercentSlice); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SlicePlan_EntityKeysSlice); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SliceRequest_PercentSlice); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_common_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SliceRequest_EntityKeysSlice); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_kaskada_kaskada_v1alpha_common_proto_msgTypes[0].OneofWrappers = []interface{}{
		(*FilePath_ParquetPath)(nil),
		(*FilePath_CsvPath)(nil),
		(*FilePath_CsvData)(nil),
	}
	file_kaskada_kaskada_v1alpha_common_proto_msgTypes[8].OneofWrappers = []interface{}{
		(*SlicePlan_Percent)(nil),
		(*SlicePlan_EntityKeys)(nil),
	}
	file_kaskada_kaskada_v1alpha_common_proto_msgTypes[10].OneofWrappers = []interface{}{
		(*SliceRequest_Percent)(nil),
		(*SliceRequest_EntityKeys)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_kaskada_kaskada_v1alpha_common_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_kaskada_kaskada_v1alpha_common_proto_goTypes,
		DependencyIndexes: file_kaskada_kaskada_v1alpha_common_proto_depIdxs,
		EnumInfos:         file_kaskada_kaskada_v1alpha_common_proto_enumTypes,
		MessageInfos:      file_kaskada_kaskada_v1alpha_common_proto_msgTypes,
	}.Build()
	File_kaskada_kaskada_v1alpha_common_proto = out.File
	file_kaskada_kaskada_v1alpha_common_proto_rawDesc = nil
	file_kaskada_kaskada_v1alpha_common_proto_goTypes = nil
	file_kaskada_kaskada_v1alpha_common_proto_depIdxs = nil
}
