// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: kaskada/kaskada/v1alpha/plan.proto

package kaskadav1alpha

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ComputePlan with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ComputePlan) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComputePlan with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ComputePlanMultiError, or
// nil if none found.
func (m *ComputePlan) ValidateAll() error {
	return m.validate(true)
}

func (m *ComputePlan) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PerEntityBehavior

	for idx, item := range m.GetOperations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComputePlanValidationError{
						field:  fmt.Sprintf("Operations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComputePlanValidationError{
						field:  fmt.Sprintf("Operations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComputePlanValidationError{
					field:  fmt.Sprintf("Operations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PrimaryGrouping

	if all {
		switch v := interface{}(m.GetPrimaryGroupingKeyType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComputePlanValidationError{
					field:  "PrimaryGroupingKeyType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComputePlanValidationError{
					field:  "PrimaryGroupingKeyType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrimaryGroupingKeyType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComputePlanValidationError{
				field:  "PrimaryGroupingKeyType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ComputePlanMultiError(errors)
	}

	return nil
}

// ComputePlanMultiError is an error wrapping multiple validation errors
// returned by ComputePlan.ValidateAll() if the designated constraints aren't met.
type ComputePlanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComputePlanMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComputePlanMultiError) AllErrors() []error { return m }

// ComputePlanValidationError is the validation error returned by
// ComputePlan.Validate if the designated constraints aren't met.
type ComputePlanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComputePlanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComputePlanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComputePlanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComputePlanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComputePlanValidationError) ErrorName() string { return "ComputePlanValidationError" }

// Error satisfies the builtin error interface
func (e ComputePlanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComputePlan.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComputePlanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComputePlanValidationError{}

// Validate checks the field values on OperationPlan with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OperationPlan) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationPlan with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OperationPlanMultiError, or
// nil if none found.
func (m *OperationPlan) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationPlan) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetExpressions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  fmt.Sprintf("Expressions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  fmt.Sprintf("Expressions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationPlanValidationError{
					field:  fmt.Sprintf("Expressions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch m.Operator.(type) {

	case *OperationPlan_Scan:

		if all {
			switch v := interface{}(m.GetScan()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "Scan",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "Scan",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScan()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationPlanValidationError{
					field:  "Scan",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OperationPlan_Merge:

		if all {
			switch v := interface{}(m.GetMerge()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "Merge",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "Merge",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMerge()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationPlanValidationError{
					field:  "Merge",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OperationPlan_Select:

		if all {
			switch v := interface{}(m.GetSelect()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "Select",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "Select",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSelect()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationPlanValidationError{
					field:  "Select",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OperationPlan_Tick:

		if all {
			switch v := interface{}(m.GetTick()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "Tick",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "Tick",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTick()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationPlanValidationError{
					field:  "Tick",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OperationPlan_WithKey:

		if all {
			switch v := interface{}(m.GetWithKey()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "WithKey",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "WithKey",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWithKey()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationPlanValidationError{
					field:  "WithKey",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OperationPlan_LookupRequest:

		if all {
			switch v := interface{}(m.GetLookupRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "LookupRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "LookupRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLookupRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationPlanValidationError{
					field:  "LookupRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OperationPlan_LookupResponse:

		if all {
			switch v := interface{}(m.GetLookupResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "LookupResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "LookupResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLookupResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationPlanValidationError{
					field:  "LookupResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OperationPlan_ShiftTo:

		if all {
			switch v := interface{}(m.GetShiftTo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "ShiftTo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "ShiftTo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetShiftTo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationPlanValidationError{
					field:  "ShiftTo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OperationPlan_ShiftUntil:

		if all {
			switch v := interface{}(m.GetShiftUntil()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "ShiftUntil",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationPlanValidationError{
						field:  "ShiftUntil",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetShiftUntil()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationPlanValidationError{
					field:  "ShiftUntil",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OperationPlanMultiError(errors)
	}

	return nil
}

// OperationPlanMultiError is an error wrapping multiple validation errors
// returned by OperationPlan.ValidateAll() if the designated constraints
// aren't met.
type OperationPlanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationPlanMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationPlanMultiError) AllErrors() []error { return m }

// OperationPlanValidationError is the validation error returned by
// OperationPlan.Validate if the designated constraints aren't met.
type OperationPlanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationPlanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationPlanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationPlanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationPlanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationPlanValidationError) ErrorName() string { return "OperationPlanValidationError" }

// Error satisfies the builtin error interface
func (e OperationPlanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationPlan.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationPlanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationPlanValidationError{}

// Validate checks the field values on ExpressionPlan with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpressionPlan) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpressionPlan with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpressionPlanMultiError,
// or nil if none found.
func (m *ExpressionPlan) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpressionPlan) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResultType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpressionPlanValidationError{
					field:  "ResultType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpressionPlanValidationError{
					field:  "ResultType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResultType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpressionPlanValidationError{
				field:  "ResultType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Output

	switch m.Operator.(type) {

	case *ExpressionPlan_Instruction:
		// no validation rules for Instruction

	case *ExpressionPlan_Input:

		if all {
			switch v := interface{}(m.GetInput()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpressionPlanValidationError{
						field:  "Input",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpressionPlanValidationError{
						field:  "Input",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpressionPlanValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpressionPlan_Literal:

		if all {
			switch v := interface{}(m.GetLiteral()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpressionPlanValidationError{
						field:  "Literal",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpressionPlanValidationError{
						field:  "Literal",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLiteral()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpressionPlanValidationError{
					field:  "Literal",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExpressionPlan_LateBound:
		// no validation rules for LateBound

	}

	if len(errors) > 0 {
		return ExpressionPlanMultiError(errors)
	}

	return nil
}

// ExpressionPlanMultiError is an error wrapping multiple validation errors
// returned by ExpressionPlan.ValidateAll() if the designated constraints
// aren't met.
type ExpressionPlanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpressionPlanMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpressionPlanMultiError) AllErrors() []error { return m }

// ExpressionPlanValidationError is the validation error returned by
// ExpressionPlan.Validate if the designated constraints aren't met.
type ExpressionPlanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpressionPlanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpressionPlanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpressionPlanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpressionPlanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpressionPlanValidationError) ErrorName() string { return "ExpressionPlanValidationError" }

// Error satisfies the builtin error interface
func (e ExpressionPlanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpressionPlan.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpressionPlanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpressionPlanValidationError{}

// Validate checks the field values on Literal with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Literal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Literal with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LiteralMultiError, or nil if none found.
func (m *Literal) ValidateAll() error {
	return m.validate(true)
}

func (m *Literal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Literal.(type) {

	case *Literal_Bool:
		// no validation rules for Bool

	case *Literal_Int8:
		// no validation rules for Int8

	case *Literal_Int16:
		// no validation rules for Int16

	case *Literal_Int32:
		// no validation rules for Int32

	case *Literal_Int64:
		// no validation rules for Int64

	case *Literal_Uint8:
		// no validation rules for Uint8

	case *Literal_Uint16:
		// no validation rules for Uint16

	case *Literal_Uint32:
		// no validation rules for Uint32

	case *Literal_Uint64:
		// no validation rules for Uint64

	case *Literal_Float32:
		// no validation rules for Float32

	case *Literal_Float64:
		// no validation rules for Float64

	case *Literal_Timestamp:

		if all {
			switch v := interface{}(m.GetTimestamp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LiteralValidationError{
						field:  "Timestamp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LiteralValidationError{
						field:  "Timestamp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LiteralValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Literal_Date32:
		// no validation rules for Date32

	case *Literal_Date64:
		// no validation rules for Date64

	case *Literal_Time32:

		if all {
			switch v := interface{}(m.GetTime32()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LiteralValidationError{
						field:  "Time32",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LiteralValidationError{
						field:  "Time32",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTime32()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LiteralValidationError{
					field:  "Time32",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Literal_Time64:

		if all {
			switch v := interface{}(m.GetTime64()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LiteralValidationError{
						field:  "Time64",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LiteralValidationError{
						field:  "Time64",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTime64()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LiteralValidationError{
					field:  "Time64",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Literal_Duration:

		if all {
			switch v := interface{}(m.GetDuration()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LiteralValidationError{
						field:  "Duration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LiteralValidationError{
						field:  "Duration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDuration()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LiteralValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Literal_IntervalDayTime:

		if all {
			switch v := interface{}(m.GetIntervalDayTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LiteralValidationError{
						field:  "IntervalDayTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LiteralValidationError{
						field:  "IntervalDayTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIntervalDayTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LiteralValidationError{
					field:  "IntervalDayTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Literal_IntervalMonths:
		// no validation rules for IntervalMonths

	case *Literal_Utf8:
		// no validation rules for Utf8

	case *Literal_Record:

		if all {
			switch v := interface{}(m.GetRecord()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LiteralValidationError{
						field:  "Record",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LiteralValidationError{
						field:  "Record",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRecord()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LiteralValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LiteralMultiError(errors)
	}

	return nil
}

// LiteralMultiError is an error wrapping multiple validation errors returned
// by Literal.ValidateAll() if the designated constraints aren't met.
type LiteralMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LiteralMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LiteralMultiError) AllErrors() []error { return m }

// LiteralValidationError is the validation error returned by Literal.Validate
// if the designated constraints aren't met.
type LiteralValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LiteralValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LiteralValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LiteralValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LiteralValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LiteralValidationError) ErrorName() string { return "LiteralValidationError" }

// Error satisfies the builtin error interface
func (e LiteralValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiteral.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LiteralValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LiteralValidationError{}

// Validate checks the field values on OperationInputRef with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OperationInputRef) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationInputRef with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationInputRefMultiError, or nil if none found.
func (m *OperationInputRef) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationInputRef) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProducingOperation

	// no validation rules for InputColumn

	// no validation rules for Interpolation

	switch m.Column.(type) {

	case *OperationInputRef_KeyColumn_:
		// no validation rules for KeyColumn

	case *OperationInputRef_ProducerExpression:
		// no validation rules for ProducerExpression

	case *OperationInputRef_ScanRecord:

		if all {
			switch v := interface{}(m.GetScanRecord()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationInputRefValidationError{
						field:  "ScanRecord",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationInputRefValidationError{
						field:  "ScanRecord",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanRecord()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationInputRefValidationError{
					field:  "ScanRecord",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OperationInputRef_Tick:

		if all {
			switch v := interface{}(m.GetTick()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationInputRefValidationError{
						field:  "Tick",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationInputRefValidationError{
						field:  "Tick",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTick()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationInputRefValidationError{
					field:  "Tick",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OperationInputRefMultiError(errors)
	}

	return nil
}

// OperationInputRefMultiError is an error wrapping multiple validation errors
// returned by OperationInputRef.ValidateAll() if the designated constraints
// aren't met.
type OperationInputRefMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationInputRefMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationInputRefMultiError) AllErrors() []error { return m }

// OperationInputRefValidationError is the validation error returned by
// OperationInputRef.Validate if the designated constraints aren't met.
type OperationInputRefValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationInputRefValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationInputRefValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationInputRefValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationInputRefValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationInputRefValidationError) ErrorName() string {
	return "OperationInputRefValidationError"
}

// Error satisfies the builtin error interface
func (e OperationInputRefValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationInputRef.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationInputRefValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationInputRefValidationError{}

// Validate checks the field values on OperationPlan_ScanOperation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationPlan_ScanOperation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationPlan_ScanOperation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationPlan_ScanOperationMultiError, or nil if none found.
func (m *OperationPlan_ScanOperation) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationPlan_ScanOperation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTableId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationPlan_ScanOperationValidationError{
					field:  "TableId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationPlan_ScanOperationValidationError{
					field:  "TableId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTableId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationPlan_ScanOperationValidationError{
				field:  "TableId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationPlan_ScanOperationValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationPlan_ScanOperationValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationPlan_ScanOperationValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSlicePlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationPlan_ScanOperationValidationError{
					field:  "SlicePlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationPlan_ScanOperationValidationError{
					field:  "SlicePlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSlicePlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationPlan_ScanOperationValidationError{
				field:  "SlicePlan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperationPlan_ScanOperationMultiError(errors)
	}

	return nil
}

// OperationPlan_ScanOperationMultiError is an error wrapping multiple
// validation errors returned by OperationPlan_ScanOperation.ValidateAll() if
// the designated constraints aren't met.
type OperationPlan_ScanOperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationPlan_ScanOperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationPlan_ScanOperationMultiError) AllErrors() []error { return m }

// OperationPlan_ScanOperationValidationError is the validation error returned
// by OperationPlan_ScanOperation.Validate if the designated constraints
// aren't met.
type OperationPlan_ScanOperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationPlan_ScanOperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationPlan_ScanOperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationPlan_ScanOperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationPlan_ScanOperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationPlan_ScanOperationValidationError) ErrorName() string {
	return "OperationPlan_ScanOperationValidationError"
}

// Error satisfies the builtin error interface
func (e OperationPlan_ScanOperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationPlan_ScanOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationPlan_ScanOperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationPlan_ScanOperationValidationError{}

// Validate checks the field values on OperationPlan_MergeOperation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationPlan_MergeOperation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationPlan_MergeOperation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationPlan_MergeOperationMultiError, or nil if none found.
func (m *OperationPlan_MergeOperation) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationPlan_MergeOperation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Left

	// no validation rules for Right

	if len(errors) > 0 {
		return OperationPlan_MergeOperationMultiError(errors)
	}

	return nil
}

// OperationPlan_MergeOperationMultiError is an error wrapping multiple
// validation errors returned by OperationPlan_MergeOperation.ValidateAll() if
// the designated constraints aren't met.
type OperationPlan_MergeOperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationPlan_MergeOperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationPlan_MergeOperationMultiError) AllErrors() []error { return m }

// OperationPlan_MergeOperationValidationError is the validation error returned
// by OperationPlan_MergeOperation.Validate if the designated constraints
// aren't met.
type OperationPlan_MergeOperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationPlan_MergeOperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationPlan_MergeOperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationPlan_MergeOperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationPlan_MergeOperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationPlan_MergeOperationValidationError) ErrorName() string {
	return "OperationPlan_MergeOperationValidationError"
}

// Error satisfies the builtin error interface
func (e OperationPlan_MergeOperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationPlan_MergeOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationPlan_MergeOperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationPlan_MergeOperationValidationError{}

// Validate checks the field values on OperationPlan_SelectOperation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationPlan_SelectOperation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationPlan_SelectOperation with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// OperationPlan_SelectOperationMultiError, or nil if none found.
func (m *OperationPlan_SelectOperation) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationPlan_SelectOperation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Input

	if all {
		switch v := interface{}(m.GetCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationPlan_SelectOperationValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationPlan_SelectOperationValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationPlan_SelectOperationValidationError{
				field:  "Condition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperationPlan_SelectOperationMultiError(errors)
	}

	return nil
}

// OperationPlan_SelectOperationMultiError is an error wrapping multiple
// validation errors returned by OperationPlan_SelectOperation.ValidateAll()
// if the designated constraints aren't met.
type OperationPlan_SelectOperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationPlan_SelectOperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationPlan_SelectOperationMultiError) AllErrors() []error { return m }

// OperationPlan_SelectOperationValidationError is the validation error
// returned by OperationPlan_SelectOperation.Validate if the designated
// constraints aren't met.
type OperationPlan_SelectOperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationPlan_SelectOperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationPlan_SelectOperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationPlan_SelectOperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationPlan_SelectOperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationPlan_SelectOperationValidationError) ErrorName() string {
	return "OperationPlan_SelectOperationValidationError"
}

// Error satisfies the builtin error interface
func (e OperationPlan_SelectOperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationPlan_SelectOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationPlan_SelectOperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationPlan_SelectOperationValidationError{}

// Validate checks the field values on OperationPlan_WithKeyOperation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationPlan_WithKeyOperation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationPlan_WithKeyOperation with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// OperationPlan_WithKeyOperationMultiError, or nil if none found.
func (m *OperationPlan_WithKeyOperation) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationPlan_WithKeyOperation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Input

	if all {
		switch v := interface{}(m.GetNewKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationPlan_WithKeyOperationValidationError{
					field:  "NewKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationPlan_WithKeyOperationValidationError{
					field:  "NewKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationPlan_WithKeyOperationValidationError{
				field:  "NewKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Grouping

	if len(errors) > 0 {
		return OperationPlan_WithKeyOperationMultiError(errors)
	}

	return nil
}

// OperationPlan_WithKeyOperationMultiError is an error wrapping multiple
// validation errors returned by OperationPlan_WithKeyOperation.ValidateAll()
// if the designated constraints aren't met.
type OperationPlan_WithKeyOperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationPlan_WithKeyOperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationPlan_WithKeyOperationMultiError) AllErrors() []error { return m }

// OperationPlan_WithKeyOperationValidationError is the validation error
// returned by OperationPlan_WithKeyOperation.Validate if the designated
// constraints aren't met.
type OperationPlan_WithKeyOperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationPlan_WithKeyOperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationPlan_WithKeyOperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationPlan_WithKeyOperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationPlan_WithKeyOperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationPlan_WithKeyOperationValidationError) ErrorName() string {
	return "OperationPlan_WithKeyOperationValidationError"
}

// Error satisfies the builtin error interface
func (e OperationPlan_WithKeyOperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationPlan_WithKeyOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationPlan_WithKeyOperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationPlan_WithKeyOperationValidationError{}

// Validate checks the field values on OperationPlan_TickOperation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationPlan_TickOperation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationPlan_TickOperation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationPlan_TickOperationMultiError, or nil if none found.
func (m *OperationPlan_TickOperation) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationPlan_TickOperation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Behavior

	// no validation rules for Input

	if len(errors) > 0 {
		return OperationPlan_TickOperationMultiError(errors)
	}

	return nil
}

// OperationPlan_TickOperationMultiError is an error wrapping multiple
// validation errors returned by OperationPlan_TickOperation.ValidateAll() if
// the designated constraints aren't met.
type OperationPlan_TickOperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationPlan_TickOperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationPlan_TickOperationMultiError) AllErrors() []error { return m }

// OperationPlan_TickOperationValidationError is the validation error returned
// by OperationPlan_TickOperation.Validate if the designated constraints
// aren't met.
type OperationPlan_TickOperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationPlan_TickOperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationPlan_TickOperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationPlan_TickOperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationPlan_TickOperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationPlan_TickOperationValidationError) ErrorName() string {
	return "OperationPlan_TickOperationValidationError"
}

// Error satisfies the builtin error interface
func (e OperationPlan_TickOperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationPlan_TickOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationPlan_TickOperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationPlan_TickOperationValidationError{}

// Validate checks the field values on OperationPlan_LookupRequestOperation
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *OperationPlan_LookupRequestOperation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationPlan_LookupRequestOperation
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// OperationPlan_LookupRequestOperationMultiError, or nil if none found.
func (m *OperationPlan_LookupRequestOperation) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationPlan_LookupRequestOperation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PrimaryOperation

	if all {
		switch v := interface{}(m.GetForeignKeyHash()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationPlan_LookupRequestOperationValidationError{
					field:  "ForeignKeyHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationPlan_LookupRequestOperationValidationError{
					field:  "ForeignKeyHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetForeignKeyHash()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationPlan_LookupRequestOperationValidationError{
				field:  "ForeignKeyHash",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperationPlan_LookupRequestOperationMultiError(errors)
	}

	return nil
}

// OperationPlan_LookupRequestOperationMultiError is an error wrapping multiple
// validation errors returned by
// OperationPlan_LookupRequestOperation.ValidateAll() if the designated
// constraints aren't met.
type OperationPlan_LookupRequestOperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationPlan_LookupRequestOperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationPlan_LookupRequestOperationMultiError) AllErrors() []error { return m }

// OperationPlan_LookupRequestOperationValidationError is the validation error
// returned by OperationPlan_LookupRequestOperation.Validate if the designated
// constraints aren't met.
type OperationPlan_LookupRequestOperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationPlan_LookupRequestOperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationPlan_LookupRequestOperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationPlan_LookupRequestOperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationPlan_LookupRequestOperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationPlan_LookupRequestOperationValidationError) ErrorName() string {
	return "OperationPlan_LookupRequestOperationValidationError"
}

// Error satisfies the builtin error interface
func (e OperationPlan_LookupRequestOperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationPlan_LookupRequestOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationPlan_LookupRequestOperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationPlan_LookupRequestOperationValidationError{}

// Validate checks the field values on OperationPlan_LookupResponseOperation
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *OperationPlan_LookupResponseOperation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationPlan_LookupResponseOperation
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// OperationPlan_LookupResponseOperationMultiError, or nil if none found.
func (m *OperationPlan_LookupResponseOperation) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationPlan_LookupResponseOperation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ForeignOperation

	if all {
		switch v := interface{}(m.GetRequestingKeyHash()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationPlan_LookupResponseOperationValidationError{
					field:  "RequestingKeyHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationPlan_LookupResponseOperationValidationError{
					field:  "RequestingKeyHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestingKeyHash()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationPlan_LookupResponseOperationValidationError{
				field:  "RequestingKeyHash",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperationPlan_LookupResponseOperationMultiError(errors)
	}

	return nil
}

// OperationPlan_LookupResponseOperationMultiError is an error wrapping
// multiple validation errors returned by
// OperationPlan_LookupResponseOperation.ValidateAll() if the designated
// constraints aren't met.
type OperationPlan_LookupResponseOperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationPlan_LookupResponseOperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationPlan_LookupResponseOperationMultiError) AllErrors() []error { return m }

// OperationPlan_LookupResponseOperationValidationError is the validation error
// returned by OperationPlan_LookupResponseOperation.Validate if the
// designated constraints aren't met.
type OperationPlan_LookupResponseOperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationPlan_LookupResponseOperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationPlan_LookupResponseOperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationPlan_LookupResponseOperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationPlan_LookupResponseOperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationPlan_LookupResponseOperationValidationError) ErrorName() string {
	return "OperationPlan_LookupResponseOperationValidationError"
}

// Error satisfies the builtin error interface
func (e OperationPlan_LookupResponseOperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationPlan_LookupResponseOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationPlan_LookupResponseOperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationPlan_LookupResponseOperationValidationError{}

// Validate checks the field values on OperationPlan_ShiftToOperation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationPlan_ShiftToOperation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationPlan_ShiftToOperation with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// OperationPlan_ShiftToOperationMultiError, or nil if none found.
func (m *OperationPlan_ShiftToOperation) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationPlan_ShiftToOperation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Input

	switch m.Time.(type) {

	case *OperationPlan_ShiftToOperation_Computed:

		if all {
			switch v := interface{}(m.GetComputed()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationPlan_ShiftToOperationValidationError{
						field:  "Computed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationPlan_ShiftToOperationValidationError{
						field:  "Computed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetComputed()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationPlan_ShiftToOperationValidationError{
					field:  "Computed",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OperationPlan_ShiftToOperation_Literal:

		if all {
			switch v := interface{}(m.GetLiteral()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationPlan_ShiftToOperationValidationError{
						field:  "Literal",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationPlan_ShiftToOperationValidationError{
						field:  "Literal",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLiteral()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationPlan_ShiftToOperationValidationError{
					field:  "Literal",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OperationPlan_ShiftToOperationMultiError(errors)
	}

	return nil
}

// OperationPlan_ShiftToOperationMultiError is an error wrapping multiple
// validation errors returned by OperationPlan_ShiftToOperation.ValidateAll()
// if the designated constraints aren't met.
type OperationPlan_ShiftToOperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationPlan_ShiftToOperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationPlan_ShiftToOperationMultiError) AllErrors() []error { return m }

// OperationPlan_ShiftToOperationValidationError is the validation error
// returned by OperationPlan_ShiftToOperation.Validate if the designated
// constraints aren't met.
type OperationPlan_ShiftToOperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationPlan_ShiftToOperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationPlan_ShiftToOperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationPlan_ShiftToOperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationPlan_ShiftToOperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationPlan_ShiftToOperationValidationError) ErrorName() string {
	return "OperationPlan_ShiftToOperationValidationError"
}

// Error satisfies the builtin error interface
func (e OperationPlan_ShiftToOperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationPlan_ShiftToOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationPlan_ShiftToOperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationPlan_ShiftToOperationValidationError{}

// Validate checks the field values on OperationPlan_ShiftUntilOperation with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *OperationPlan_ShiftUntilOperation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationPlan_ShiftUntilOperation
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// OperationPlan_ShiftUntilOperationMultiError, or nil if none found.
func (m *OperationPlan_ShiftUntilOperation) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationPlan_ShiftUntilOperation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Input

	if all {
		switch v := interface{}(m.GetCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationPlan_ShiftUntilOperationValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationPlan_ShiftUntilOperationValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationPlan_ShiftUntilOperationValidationError{
				field:  "Condition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperationPlan_ShiftUntilOperationMultiError(errors)
	}

	return nil
}

// OperationPlan_ShiftUntilOperationMultiError is an error wrapping multiple
// validation errors returned by
// OperationPlan_ShiftUntilOperation.ValidateAll() if the designated
// constraints aren't met.
type OperationPlan_ShiftUntilOperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationPlan_ShiftUntilOperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationPlan_ShiftUntilOperationMultiError) AllErrors() []error { return m }

// OperationPlan_ShiftUntilOperationValidationError is the validation error
// returned by OperationPlan_ShiftUntilOperation.Validate if the designated
// constraints aren't met.
type OperationPlan_ShiftUntilOperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationPlan_ShiftUntilOperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationPlan_ShiftUntilOperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationPlan_ShiftUntilOperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationPlan_ShiftUntilOperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationPlan_ShiftUntilOperationValidationError) ErrorName() string {
	return "OperationPlan_ShiftUntilOperationValidationError"
}

// Error satisfies the builtin error interface
func (e OperationPlan_ShiftUntilOperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationPlan_ShiftUntilOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationPlan_ShiftUntilOperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationPlan_ShiftUntilOperationValidationError{}

// Validate checks the field values on Literal_TimestampValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Literal_TimestampValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Literal_TimestampValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Literal_TimestampValueMultiError, or nil if none found.
func (m *Literal_TimestampValue) ValidateAll() error {
	return m.validate(true)
}

func (m *Literal_TimestampValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Literal_TimestampValueValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Literal_TimestampValueValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Literal_TimestampValueValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Unit

	if all {
		switch v := interface{}(m.GetTz()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Literal_TimestampValueValidationError{
					field:  "Tz",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Literal_TimestampValueValidationError{
					field:  "Tz",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTz()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Literal_TimestampValueValidationError{
				field:  "Tz",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Literal_TimestampValueMultiError(errors)
	}

	return nil
}

// Literal_TimestampValueMultiError is an error wrapping multiple validation
// errors returned by Literal_TimestampValue.ValidateAll() if the designated
// constraints aren't met.
type Literal_TimestampValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Literal_TimestampValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Literal_TimestampValueMultiError) AllErrors() []error { return m }

// Literal_TimestampValueValidationError is the validation error returned by
// Literal_TimestampValue.Validate if the designated constraints aren't met.
type Literal_TimestampValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Literal_TimestampValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Literal_TimestampValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Literal_TimestampValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Literal_TimestampValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Literal_TimestampValueValidationError) ErrorName() string {
	return "Literal_TimestampValueValidationError"
}

// Error satisfies the builtin error interface
func (e Literal_TimestampValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiteral_TimestampValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Literal_TimestampValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Literal_TimestampValueValidationError{}

// Validate checks the field values on Literal_Time32Value with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Literal_Time32Value) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Literal_Time32Value with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Literal_Time32ValueMultiError, or nil if none found.
func (m *Literal_Time32Value) ValidateAll() error {
	return m.validate(true)
}

func (m *Literal_Time32Value) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for Unit

	if len(errors) > 0 {
		return Literal_Time32ValueMultiError(errors)
	}

	return nil
}

// Literal_Time32ValueMultiError is an error wrapping multiple validation
// errors returned by Literal_Time32Value.ValidateAll() if the designated
// constraints aren't met.
type Literal_Time32ValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Literal_Time32ValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Literal_Time32ValueMultiError) AllErrors() []error { return m }

// Literal_Time32ValueValidationError is the validation error returned by
// Literal_Time32Value.Validate if the designated constraints aren't met.
type Literal_Time32ValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Literal_Time32ValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Literal_Time32ValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Literal_Time32ValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Literal_Time32ValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Literal_Time32ValueValidationError) ErrorName() string {
	return "Literal_Time32ValueValidationError"
}

// Error satisfies the builtin error interface
func (e Literal_Time32ValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiteral_Time32Value.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Literal_Time32ValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Literal_Time32ValueValidationError{}

// Validate checks the field values on Literal_Time64Value with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Literal_Time64Value) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Literal_Time64Value with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Literal_Time64ValueMultiError, or nil if none found.
func (m *Literal_Time64Value) ValidateAll() error {
	return m.validate(true)
}

func (m *Literal_Time64Value) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for Unit

	if len(errors) > 0 {
		return Literal_Time64ValueMultiError(errors)
	}

	return nil
}

// Literal_Time64ValueMultiError is an error wrapping multiple validation
// errors returned by Literal_Time64Value.ValidateAll() if the designated
// constraints aren't met.
type Literal_Time64ValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Literal_Time64ValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Literal_Time64ValueMultiError) AllErrors() []error { return m }

// Literal_Time64ValueValidationError is the validation error returned by
// Literal_Time64Value.Validate if the designated constraints aren't met.
type Literal_Time64ValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Literal_Time64ValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Literal_Time64ValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Literal_Time64ValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Literal_Time64ValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Literal_Time64ValueValidationError) ErrorName() string {
	return "Literal_Time64ValueValidationError"
}

// Error satisfies the builtin error interface
func (e Literal_Time64ValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiteral_Time64Value.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Literal_Time64ValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Literal_Time64ValueValidationError{}

// Validate checks the field values on Literal_DurationValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Literal_DurationValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Literal_DurationValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Literal_DurationValueMultiError, or nil if none found.
func (m *Literal_DurationValue) ValidateAll() error {
	return m.validate(true)
}

func (m *Literal_DurationValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for Unit

	if len(errors) > 0 {
		return Literal_DurationValueMultiError(errors)
	}

	return nil
}

// Literal_DurationValueMultiError is an error wrapping multiple validation
// errors returned by Literal_DurationValue.ValidateAll() if the designated
// constraints aren't met.
type Literal_DurationValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Literal_DurationValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Literal_DurationValueMultiError) AllErrors() []error { return m }

// Literal_DurationValueValidationError is the validation error returned by
// Literal_DurationValue.Validate if the designated constraints aren't met.
type Literal_DurationValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Literal_DurationValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Literal_DurationValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Literal_DurationValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Literal_DurationValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Literal_DurationValueValidationError) ErrorName() string {
	return "Literal_DurationValueValidationError"
}

// Error satisfies the builtin error interface
func (e Literal_DurationValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiteral_DurationValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Literal_DurationValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Literal_DurationValueValidationError{}

// Validate checks the field values on Literal_IntervalDayTimeValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Literal_IntervalDayTimeValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Literal_IntervalDayTimeValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Literal_IntervalDayTimeValueMultiError, or nil if none found.
func (m *Literal_IntervalDayTimeValue) ValidateAll() error {
	return m.validate(true)
}

func (m *Literal_IntervalDayTimeValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	if len(errors) > 0 {
		return Literal_IntervalDayTimeValueMultiError(errors)
	}

	return nil
}

// Literal_IntervalDayTimeValueMultiError is an error wrapping multiple
// validation errors returned by Literal_IntervalDayTimeValue.ValidateAll() if
// the designated constraints aren't met.
type Literal_IntervalDayTimeValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Literal_IntervalDayTimeValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Literal_IntervalDayTimeValueMultiError) AllErrors() []error { return m }

// Literal_IntervalDayTimeValueValidationError is the validation error returned
// by Literal_IntervalDayTimeValue.Validate if the designated constraints
// aren't met.
type Literal_IntervalDayTimeValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Literal_IntervalDayTimeValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Literal_IntervalDayTimeValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Literal_IntervalDayTimeValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Literal_IntervalDayTimeValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Literal_IntervalDayTimeValueValidationError) ErrorName() string {
	return "Literal_IntervalDayTimeValueValidationError"
}

// Error satisfies the builtin error interface
func (e Literal_IntervalDayTimeValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiteral_IntervalDayTimeValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Literal_IntervalDayTimeValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Literal_IntervalDayTimeValueValidationError{}

// Validate checks the field values on Literal_RecordValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Literal_RecordValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Literal_RecordValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Literal_RecordValueMultiError, or nil if none found.
func (m *Literal_RecordValue) ValidateAll() error {
	return m.validate(true)
}

func (m *Literal_RecordValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Literal_RecordValueValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Literal_RecordValueValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Literal_RecordValueValidationError{
					field:  fmt.Sprintf("Values[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Literal_RecordValueMultiError(errors)
	}

	return nil
}

// Literal_RecordValueMultiError is an error wrapping multiple validation
// errors returned by Literal_RecordValue.ValidateAll() if the designated
// constraints aren't met.
type Literal_RecordValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Literal_RecordValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Literal_RecordValueMultiError) AllErrors() []error { return m }

// Literal_RecordValueValidationError is the validation error returned by
// Literal_RecordValue.Validate if the designated constraints aren't met.
type Literal_RecordValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Literal_RecordValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Literal_RecordValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Literal_RecordValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Literal_RecordValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Literal_RecordValueValidationError) ErrorName() string {
	return "Literal_RecordValueValidationError"
}

// Error satisfies the builtin error interface
func (e Literal_RecordValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiteral_RecordValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Literal_RecordValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Literal_RecordValueValidationError{}
