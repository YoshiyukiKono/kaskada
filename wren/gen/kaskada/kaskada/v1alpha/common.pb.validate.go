// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: kaskada/kaskada/v1alpha/common.proto

package kaskadav1alpha

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on FilePath with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FilePath) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FilePath with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FilePathMultiError, or nil
// if none found.
func (m *FilePath) ValidateAll() error {
	return m.validate(true)
}

func (m *FilePath) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Path.(type) {

	case *FilePath_ParquetPath:
		// no validation rules for ParquetPath

	case *FilePath_CsvPath:
		// no validation rules for CsvPath

	case *FilePath_CsvData:
		// no validation rules for CsvData

	}

	if len(errors) > 0 {
		return FilePathMultiError(errors)
	}

	return nil
}

// FilePathMultiError is an error wrapping multiple validation errors returned
// by FilePath.ValidateAll() if the designated constraints aren't met.
type FilePathMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FilePathMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FilePathMultiError) AllErrors() []error { return m }

// FilePathValidationError is the validation error returned by
// FilePath.Validate if the designated constraints aren't met.
type FilePathValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FilePathValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FilePathValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FilePathValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FilePathValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FilePathValidationError) ErrorName() string { return "FilePathValidationError" }

// Error satisfies the builtin error interface
func (e FilePathValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFilePath.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FilePathValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FilePathValidationError{}

// Validate checks the field values on FileInput with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileInput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileInputMultiError, or nil
// if none found.
func (m *FileInput) ValidateAll() error {
	return m.validate(true)
}

func (m *FileInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileType

	// no validation rules for Uri

	if len(errors) > 0 {
		return FileInputMultiError(errors)
	}

	return nil
}

// FileInputMultiError is an error wrapping multiple validation errors returned
// by FileInput.ValidateAll() if the designated constraints aren't met.
type FileInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileInputMultiError) AllErrors() []error { return m }

// FileInputValidationError is the validation error returned by
// FileInput.Validate if the designated constraints aren't met.
type FileInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileInputValidationError) ErrorName() string { return "FileInputValidationError" }

// Error satisfies the builtin error interface
func (e FileInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileInputValidationError{}

// Validate checks the field values on FileResults with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileResults) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileResults with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileResultsMultiError, or
// nil if none found.
func (m *FileResults) ValidateAll() error {
	return m.validate(true)
}

func (m *FileResults) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileType

	if len(errors) > 0 {
		return FileResultsMultiError(errors)
	}

	return nil
}

// FileResultsMultiError is an error wrapping multiple validation errors
// returned by FileResults.ValidateAll() if the designated constraints aren't met.
type FileResultsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileResultsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileResultsMultiError) AllErrors() []error { return m }

// FileResultsValidationError is the validation error returned by
// FileResults.Validate if the designated constraints aren't met.
type FileResultsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileResultsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileResultsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileResultsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileResultsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileResultsValidationError) ErrorName() string { return "FileResultsValidationError" }

// Error satisfies the builtin error interface
func (e FileResultsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileResults.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileResultsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileResultsValidationError{}

// Validate checks the field values on AsFiles with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AsFiles) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AsFiles with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AsFilesMultiError, or nil if none found.
func (m *AsFiles) ValidateAll() error {
	return m.validate(true)
}

func (m *AsFiles) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileType

	if len(errors) > 0 {
		return AsFilesMultiError(errors)
	}

	return nil
}

// AsFilesMultiError is an error wrapping multiple validation errors returned
// by AsFiles.ValidateAll() if the designated constraints aren't met.
type AsFilesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AsFilesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AsFilesMultiError) AllErrors() []error { return m }

// AsFilesValidationError is the validation error returned by AsFiles.Validate
// if the designated constraints aren't met.
type AsFilesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AsFilesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AsFilesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AsFilesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AsFilesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AsFilesValidationError) ErrorName() string { return "AsFilesValidationError" }

// Error satisfies the builtin error interface
func (e AsFilesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAsFiles.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AsFilesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AsFilesValidationError{}

// Validate checks the field values on TableConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TableConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TableConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TableConfigMultiError, or
// nil if none found.
func (m *TableConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TableConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Uuid

	// no validation rules for TimeColumnName

	if all {
		switch v := interface{}(m.GetSubsortColumnName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TableConfigValidationError{
					field:  "SubsortColumnName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TableConfigValidationError{
					field:  "SubsortColumnName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubsortColumnName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TableConfigValidationError{
				field:  "SubsortColumnName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GroupColumnName

	// no validation rules for Grouping

	if len(errors) > 0 {
		return TableConfigMultiError(errors)
	}

	return nil
}

// TableConfigMultiError is an error wrapping multiple validation errors
// returned by TableConfig.ValidateAll() if the designated constraints aren't met.
type TableConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TableConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TableConfigMultiError) AllErrors() []error { return m }

// TableConfigValidationError is the validation error returned by
// TableConfig.Validate if the designated constraints aren't met.
type TableConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TableConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TableConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TableConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TableConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TableConfigValidationError) ErrorName() string { return "TableConfigValidationError" }

// Error satisfies the builtin error interface
func (e TableConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTableConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TableConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TableConfigValidationError{}

// Validate checks the field values on TableMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TableMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TableMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TableMetadataMultiError, or
// nil if none found.
func (m *TableMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *TableMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TableMetadataValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TableMetadataValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TableMetadataValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FileCount

	if len(errors) > 0 {
		return TableMetadataMultiError(errors)
	}

	return nil
}

// TableMetadataMultiError is an error wrapping multiple validation errors
// returned by TableMetadata.ValidateAll() if the designated constraints
// aren't met.
type TableMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TableMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TableMetadataMultiError) AllErrors() []error { return m }

// TableMetadataValidationError is the validation error returned by
// TableMetadata.Validate if the designated constraints aren't met.
type TableMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TableMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TableMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TableMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TableMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TableMetadataValidationError) ErrorName() string { return "TableMetadataValidationError" }

// Error satisfies the builtin error interface
func (e TableMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTableMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TableMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TableMetadataValidationError{}

// Validate checks the field values on PreparedFile with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PreparedFile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PreparedFile with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PreparedFileMultiError, or
// nil if none found.
func (m *PreparedFile) ValidateAll() error {
	return m.validate(true)
}

func (m *PreparedFile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	if all {
		switch v := interface{}(m.GetMinEventTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PreparedFileValidationError{
					field:  "MinEventTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PreparedFileValidationError{
					field:  "MinEventTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinEventTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PreparedFileValidationError{
				field:  "MinEventTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMaxEventTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PreparedFileValidationError{
					field:  "MaxEventTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PreparedFileValidationError{
					field:  "MaxEventTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxEventTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PreparedFileValidationError{
				field:  "MaxEventTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NumRows

	// no validation rules for MetadataPath

	if len(errors) > 0 {
		return PreparedFileMultiError(errors)
	}

	return nil
}

// PreparedFileMultiError is an error wrapping multiple validation errors
// returned by PreparedFile.ValidateAll() if the designated constraints aren't met.
type PreparedFileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreparedFileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreparedFileMultiError) AllErrors() []error { return m }

// PreparedFileValidationError is the validation error returned by
// PreparedFile.Validate if the designated constraints aren't met.
type PreparedFileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreparedFileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreparedFileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreparedFileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreparedFileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreparedFileValidationError) ErrorName() string { return "PreparedFileValidationError" }

// Error satisfies the builtin error interface
func (e PreparedFileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPreparedFile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreparedFileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreparedFileValidationError{}

// Validate checks the field values on PreparedFileMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PreparedFileMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PreparedFileMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PreparedFileMetadataMultiError, or nil if none found.
func (m *PreparedFileMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *PreparedFileMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RawFilePath

	for idx, item := range m.GetPreparedFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PreparedFileMetadataValidationError{
						field:  fmt.Sprintf("PreparedFiles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PreparedFileMetadataValidationError{
						field:  fmt.Sprintf("PreparedFiles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PreparedFileMetadataValidationError{
					field:  fmt.Sprintf("PreparedFiles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PreparedFileMetadataMultiError(errors)
	}

	return nil
}

// PreparedFileMetadataMultiError is an error wrapping multiple validation
// errors returned by PreparedFileMetadata.ValidateAll() if the designated
// constraints aren't met.
type PreparedFileMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreparedFileMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreparedFileMetadataMultiError) AllErrors() []error { return m }

// PreparedFileMetadataValidationError is the validation error returned by
// PreparedFileMetadata.Validate if the designated constraints aren't met.
type PreparedFileMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreparedFileMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreparedFileMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreparedFileMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreparedFileMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreparedFileMetadataValidationError) ErrorName() string {
	return "PreparedFileMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e PreparedFileMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPreparedFileMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreparedFileMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreparedFileMetadataValidationError{}

// Validate checks the field values on SlicePlan with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SlicePlan) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SlicePlan with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SlicePlanMultiError, or nil
// if none found.
func (m *SlicePlan) ValidateAll() error {
	return m.validate(true)
}

func (m *SlicePlan) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TableName

	switch m.Slice.(type) {

	case *SlicePlan_Percent:

		if all {
			switch v := interface{}(m.GetPercent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SlicePlanValidationError{
						field:  "Percent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SlicePlanValidationError{
						field:  "Percent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPercent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SlicePlanValidationError{
					field:  "Percent",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SlicePlan_EntityKeys:

		if all {
			switch v := interface{}(m.GetEntityKeys()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SlicePlanValidationError{
						field:  "EntityKeys",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SlicePlanValidationError{
						field:  "EntityKeys",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEntityKeys()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SlicePlanValidationError{
					field:  "EntityKeys",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SlicePlanMultiError(errors)
	}

	return nil
}

// SlicePlanMultiError is an error wrapping multiple validation errors returned
// by SlicePlan.ValidateAll() if the designated constraints aren't met.
type SlicePlanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SlicePlanMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SlicePlanMultiError) AllErrors() []error { return m }

// SlicePlanValidationError is the validation error returned by
// SlicePlan.Validate if the designated constraints aren't met.
type SlicePlanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SlicePlanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SlicePlanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SlicePlanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SlicePlanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SlicePlanValidationError) ErrorName() string { return "SlicePlanValidationError" }

// Error satisfies the builtin error interface
func (e SlicePlanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSlicePlan.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SlicePlanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SlicePlanValidationError{}

// Validate checks the field values on Uuid with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Uuid) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Uuid with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UuidMultiError, or nil if none found.
func (m *Uuid) ValidateAll() error {
	return m.validate(true)
}

func (m *Uuid) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for High

	// no validation rules for Low

	if len(errors) > 0 {
		return UuidMultiError(errors)
	}

	return nil
}

// UuidMultiError is an error wrapping multiple validation errors returned by
// Uuid.ValidateAll() if the designated constraints aren't met.
type UuidMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UuidMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UuidMultiError) AllErrors() []error { return m }

// UuidValidationError is the validation error returned by Uuid.Validate if the
// designated constraints aren't met.
type UuidValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UuidValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UuidValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UuidValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UuidValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UuidValidationError) ErrorName() string { return "UuidValidationError" }

// Error satisfies the builtin error interface
func (e UuidValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUuid.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UuidValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UuidValidationError{}

// Validate checks the field values on SliceRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SliceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SliceRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SliceRequestMultiError, or
// nil if none found.
func (m *SliceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SliceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Slice.(type) {

	case *SliceRequest_Percent:

		if all {
			switch v := interface{}(m.GetPercent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SliceRequestValidationError{
						field:  "Percent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SliceRequestValidationError{
						field:  "Percent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPercent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SliceRequestValidationError{
					field:  "Percent",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SliceRequest_EntityKeys:

		if all {
			switch v := interface{}(m.GetEntityKeys()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SliceRequestValidationError{
						field:  "EntityKeys",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SliceRequestValidationError{
						field:  "EntityKeys",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEntityKeys()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SliceRequestValidationError{
					field:  "EntityKeys",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SliceRequestMultiError(errors)
	}

	return nil
}

// SliceRequestMultiError is an error wrapping multiple validation errors
// returned by SliceRequest.ValidateAll() if the designated constraints aren't met.
type SliceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SliceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SliceRequestMultiError) AllErrors() []error { return m }

// SliceRequestValidationError is the validation error returned by
// SliceRequest.Validate if the designated constraints aren't met.
type SliceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SliceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SliceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SliceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SliceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SliceRequestValidationError) ErrorName() string { return "SliceRequestValidationError" }

// Error satisfies the builtin error interface
func (e SliceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSliceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SliceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SliceRequestValidationError{}

// Validate checks the field values on Analysis with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Analysis) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Analysis with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AnalysisMultiError, or nil
// if none found.
func (m *Analysis) ValidateAll() error {
	return m.validate(true)
}

func (m *Analysis) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFenlDiagnostics()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnalysisValidationError{
					field:  "FenlDiagnostics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnalysisValidationError{
					field:  "FenlDiagnostics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFenlDiagnostics()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnalysisValidationError{
				field:  "FenlDiagnostics",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CanExecute

	if len(errors) > 0 {
		return AnalysisMultiError(errors)
	}

	return nil
}

// AnalysisMultiError is an error wrapping multiple validation errors returned
// by Analysis.ValidateAll() if the designated constraints aren't met.
type AnalysisMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnalysisMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnalysisMultiError) AllErrors() []error { return m }

// AnalysisValidationError is the validation error returned by
// Analysis.Validate if the designated constraints aren't met.
type AnalysisValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnalysisValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnalysisValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnalysisValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnalysisValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnalysisValidationError) ErrorName() string { return "AnalysisValidationError" }

// Error satisfies the builtin error interface
func (e AnalysisValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnalysis.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnalysisValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnalysisValidationError{}

// Validate checks the field values on RequestDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RequestDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RequestDetailsMultiError,
// or nil if none found.
func (m *RequestDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	if len(errors) > 0 {
		return RequestDetailsMultiError(errors)
	}

	return nil
}

// RequestDetailsMultiError is an error wrapping multiple validation errors
// returned by RequestDetails.ValidateAll() if the designated constraints
// aren't met.
type RequestDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestDetailsMultiError) AllErrors() []error { return m }

// RequestDetailsValidationError is the validation error returned by
// RequestDetails.Validate if the designated constraints aren't met.
type RequestDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestDetailsValidationError) ErrorName() string { return "RequestDetailsValidationError" }

// Error satisfies the builtin error interface
func (e RequestDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestDetailsValidationError{}

// Validate checks the field values on SlicePlan_PercentSlice with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SlicePlan_PercentSlice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SlicePlan_PercentSlice with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SlicePlan_PercentSliceMultiError, or nil if none found.
func (m *SlicePlan_PercentSlice) ValidateAll() error {
	return m.validate(true)
}

func (m *SlicePlan_PercentSlice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Percent

	if len(errors) > 0 {
		return SlicePlan_PercentSliceMultiError(errors)
	}

	return nil
}

// SlicePlan_PercentSliceMultiError is an error wrapping multiple validation
// errors returned by SlicePlan_PercentSlice.ValidateAll() if the designated
// constraints aren't met.
type SlicePlan_PercentSliceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SlicePlan_PercentSliceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SlicePlan_PercentSliceMultiError) AllErrors() []error { return m }

// SlicePlan_PercentSliceValidationError is the validation error returned by
// SlicePlan_PercentSlice.Validate if the designated constraints aren't met.
type SlicePlan_PercentSliceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SlicePlan_PercentSliceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SlicePlan_PercentSliceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SlicePlan_PercentSliceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SlicePlan_PercentSliceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SlicePlan_PercentSliceValidationError) ErrorName() string {
	return "SlicePlan_PercentSliceValidationError"
}

// Error satisfies the builtin error interface
func (e SlicePlan_PercentSliceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSlicePlan_PercentSlice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SlicePlan_PercentSliceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SlicePlan_PercentSliceValidationError{}

// Validate checks the field values on SlicePlan_EntityKeysSlice with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SlicePlan_EntityKeysSlice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SlicePlan_EntityKeysSlice with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SlicePlan_EntityKeysSliceMultiError, or nil if none found.
func (m *SlicePlan_EntityKeysSlice) ValidateAll() error {
	return m.validate(true)
}

func (m *SlicePlan_EntityKeysSlice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SlicePlan_EntityKeysSliceMultiError(errors)
	}

	return nil
}

// SlicePlan_EntityKeysSliceMultiError is an error wrapping multiple validation
// errors returned by SlicePlan_EntityKeysSlice.ValidateAll() if the
// designated constraints aren't met.
type SlicePlan_EntityKeysSliceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SlicePlan_EntityKeysSliceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SlicePlan_EntityKeysSliceMultiError) AllErrors() []error { return m }

// SlicePlan_EntityKeysSliceValidationError is the validation error returned by
// SlicePlan_EntityKeysSlice.Validate if the designated constraints aren't met.
type SlicePlan_EntityKeysSliceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SlicePlan_EntityKeysSliceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SlicePlan_EntityKeysSliceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SlicePlan_EntityKeysSliceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SlicePlan_EntityKeysSliceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SlicePlan_EntityKeysSliceValidationError) ErrorName() string {
	return "SlicePlan_EntityKeysSliceValidationError"
}

// Error satisfies the builtin error interface
func (e SlicePlan_EntityKeysSliceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSlicePlan_EntityKeysSlice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SlicePlan_EntityKeysSliceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SlicePlan_EntityKeysSliceValidationError{}

// Validate checks the field values on SliceRequest_PercentSlice with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SliceRequest_PercentSlice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SliceRequest_PercentSlice with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SliceRequest_PercentSliceMultiError, or nil if none found.
func (m *SliceRequest_PercentSlice) ValidateAll() error {
	return m.validate(true)
}

func (m *SliceRequest_PercentSlice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Percent

	if len(errors) > 0 {
		return SliceRequest_PercentSliceMultiError(errors)
	}

	return nil
}

// SliceRequest_PercentSliceMultiError is an error wrapping multiple validation
// errors returned by SliceRequest_PercentSlice.ValidateAll() if the
// designated constraints aren't met.
type SliceRequest_PercentSliceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SliceRequest_PercentSliceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SliceRequest_PercentSliceMultiError) AllErrors() []error { return m }

// SliceRequest_PercentSliceValidationError is the validation error returned by
// SliceRequest_PercentSlice.Validate if the designated constraints aren't met.
type SliceRequest_PercentSliceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SliceRequest_PercentSliceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SliceRequest_PercentSliceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SliceRequest_PercentSliceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SliceRequest_PercentSliceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SliceRequest_PercentSliceValidationError) ErrorName() string {
	return "SliceRequest_PercentSliceValidationError"
}

// Error satisfies the builtin error interface
func (e SliceRequest_PercentSliceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSliceRequest_PercentSlice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SliceRequest_PercentSliceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SliceRequest_PercentSliceValidationError{}

// Validate checks the field values on SliceRequest_EntityKeysSlice with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SliceRequest_EntityKeysSlice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SliceRequest_EntityKeysSlice with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SliceRequest_EntityKeysSliceMultiError, or nil if none found.
func (m *SliceRequest_EntityKeysSlice) ValidateAll() error {
	return m.validate(true)
}

func (m *SliceRequest_EntityKeysSlice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SliceRequest_EntityKeysSliceMultiError(errors)
	}

	return nil
}

// SliceRequest_EntityKeysSliceMultiError is an error wrapping multiple
// validation errors returned by SliceRequest_EntityKeysSlice.ValidateAll() if
// the designated constraints aren't met.
type SliceRequest_EntityKeysSliceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SliceRequest_EntityKeysSliceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SliceRequest_EntityKeysSliceMultiError) AllErrors() []error { return m }

// SliceRequest_EntityKeysSliceValidationError is the validation error returned
// by SliceRequest_EntityKeysSlice.Validate if the designated constraints
// aren't met.
type SliceRequest_EntityKeysSliceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SliceRequest_EntityKeysSliceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SliceRequest_EntityKeysSliceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SliceRequest_EntityKeysSliceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SliceRequest_EntityKeysSliceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SliceRequest_EntityKeysSliceValidationError) ErrorName() string {
	return "SliceRequest_EntityKeysSliceValidationError"
}

// Error satisfies the builtin error interface
func (e SliceRequest_EntityKeysSliceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSliceRequest_EntityKeysSlice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SliceRequest_EntityKeysSliceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SliceRequest_EntityKeysSliceValidationError{}
