// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0-devel
// 	protoc        (unknown)
// source: kaskada/kaskada/v1alpha/plan.proto

package kaskadav1alpha

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type LateBoundValue int32

const (
	LateBoundValue_LATE_BOUND_VALUE_UNSPECIFIED        LateBoundValue = 0
	LateBoundValue_LATE_BOUND_VALUE_CHANGED_SINCE_TIME LateBoundValue = 1
	LateBoundValue_LATE_BOUND_VALUE_FINAL_AT_TIME      LateBoundValue = 2
)

// Enum value maps for LateBoundValue.
var (
	LateBoundValue_name = map[int32]string{
		0: "LATE_BOUND_VALUE_UNSPECIFIED",
		1: "LATE_BOUND_VALUE_CHANGED_SINCE_TIME",
		2: "LATE_BOUND_VALUE_FINAL_AT_TIME",
	}
	LateBoundValue_value = map[string]int32{
		"LATE_BOUND_VALUE_UNSPECIFIED":        0,
		"LATE_BOUND_VALUE_CHANGED_SINCE_TIME": 1,
		"LATE_BOUND_VALUE_FINAL_AT_TIME":      2,
	}
)

func (x LateBoundValue) Enum() *LateBoundValue {
	p := new(LateBoundValue)
	*p = x
	return p
}

func (x LateBoundValue) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LateBoundValue) Descriptor() protoreflect.EnumDescriptor {
	return file_kaskada_kaskada_v1alpha_plan_proto_enumTypes[0].Descriptor()
}

func (LateBoundValue) Type() protoreflect.EnumType {
	return &file_kaskada_kaskada_v1alpha_plan_proto_enumTypes[0]
}

func (x LateBoundValue) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LateBoundValue.Descriptor instead.
func (LateBoundValue) EnumDescriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{0}
}

type OperationPlan_TickOperation_TickBehavior int32

const (
	OperationPlan_TickOperation_TICK_BEHAVIOR_UNSPECIFIED OperationPlan_TickOperation_TickBehavior = 0
	// Tick once after all other inputs have been processed.
	// Corresponds to "after all events".
	OperationPlan_TickOperation_TICK_BEHAVIOR_FINISHED OperationPlan_TickOperation_TickBehavior = 1
	OperationPlan_TickOperation_TICK_BEHAVIOR_HOURLY   OperationPlan_TickOperation_TickBehavior = 2
	OperationPlan_TickOperation_TICK_BEHAVIOR_DAILY    OperationPlan_TickOperation_TickBehavior = 3
	OperationPlan_TickOperation_TICK_BEHAVIOR_MONTHLY  OperationPlan_TickOperation_TickBehavior = 4
	OperationPlan_TickOperation_TICK_BEHAVIOR_YEARLY   OperationPlan_TickOperation_TickBehavior = 5
	OperationPlan_TickOperation_TICK_BEHAVIOR_MINUTELY OperationPlan_TickOperation_TickBehavior = 6
)

// Enum value maps for OperationPlan_TickOperation_TickBehavior.
var (
	OperationPlan_TickOperation_TickBehavior_name = map[int32]string{
		0: "TICK_BEHAVIOR_UNSPECIFIED",
		1: "TICK_BEHAVIOR_FINISHED",
		2: "TICK_BEHAVIOR_HOURLY",
		3: "TICK_BEHAVIOR_DAILY",
		4: "TICK_BEHAVIOR_MONTHLY",
		5: "TICK_BEHAVIOR_YEARLY",
		6: "TICK_BEHAVIOR_MINUTELY",
	}
	OperationPlan_TickOperation_TickBehavior_value = map[string]int32{
		"TICK_BEHAVIOR_UNSPECIFIED": 0,
		"TICK_BEHAVIOR_FINISHED":    1,
		"TICK_BEHAVIOR_HOURLY":      2,
		"TICK_BEHAVIOR_DAILY":       3,
		"TICK_BEHAVIOR_MONTHLY":     4,
		"TICK_BEHAVIOR_YEARLY":      5,
		"TICK_BEHAVIOR_MINUTELY":    6,
	}
)

func (x OperationPlan_TickOperation_TickBehavior) Enum() *OperationPlan_TickOperation_TickBehavior {
	p := new(OperationPlan_TickOperation_TickBehavior)
	*p = x
	return p
}

func (x OperationPlan_TickOperation_TickBehavior) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OperationPlan_TickOperation_TickBehavior) Descriptor() protoreflect.EnumDescriptor {
	return file_kaskada_kaskada_v1alpha_plan_proto_enumTypes[1].Descriptor()
}

func (OperationPlan_TickOperation_TickBehavior) Type() protoreflect.EnumType {
	return &file_kaskada_kaskada_v1alpha_plan_proto_enumTypes[1]
}

func (x OperationPlan_TickOperation_TickBehavior) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OperationPlan_TickOperation_TickBehavior.Descriptor instead.
func (OperationPlan_TickOperation_TickBehavior) EnumDescriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{1, 4, 0}
}

type OperationInputRef_KeyColumn int32

const (
	OperationInputRef_KEY_COLUMN_UNSPECIFIED OperationInputRef_KeyColumn = 0
	OperationInputRef_KEY_COLUMN_TIME        OperationInputRef_KeyColumn = 1
	OperationInputRef_KEY_COLUMN_SUBSORT     OperationInputRef_KeyColumn = 2
	OperationInputRef_KEY_COLUMN_KEY_HASH    OperationInputRef_KeyColumn = 3
)

// Enum value maps for OperationInputRef_KeyColumn.
var (
	OperationInputRef_KeyColumn_name = map[int32]string{
		0: "KEY_COLUMN_UNSPECIFIED",
		1: "KEY_COLUMN_TIME",
		2: "KEY_COLUMN_SUBSORT",
		3: "KEY_COLUMN_KEY_HASH",
	}
	OperationInputRef_KeyColumn_value = map[string]int32{
		"KEY_COLUMN_UNSPECIFIED": 0,
		"KEY_COLUMN_TIME":        1,
		"KEY_COLUMN_SUBSORT":     2,
		"KEY_COLUMN_KEY_HASH":    3,
	}
)

func (x OperationInputRef_KeyColumn) Enum() *OperationInputRef_KeyColumn {
	p := new(OperationInputRef_KeyColumn)
	*p = x
	return p
}

func (x OperationInputRef_KeyColumn) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OperationInputRef_KeyColumn) Descriptor() protoreflect.EnumDescriptor {
	return file_kaskada_kaskada_v1alpha_plan_proto_enumTypes[2].Descriptor()
}

func (OperationInputRef_KeyColumn) Type() protoreflect.EnumType {
	return &file_kaskada_kaskada_v1alpha_plan_proto_enumTypes[2]
}

func (x OperationInputRef_KeyColumn) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OperationInputRef_KeyColumn.Descriptor instead.
func (OperationInputRef_KeyColumn) EnumDescriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{4, 0}
}

// How values should be interpolated.
//
// This is currently only respected in merge operations, but that should
// be OK since that is the only operation that introduces new rows. We may
// need to include interpolation in other places such as `TickOperation`.
type OperationInputRef_Interpolation int32

const (
	OperationInputRef_INTERPOLATION_UNSPECIFIED OperationInputRef_Interpolation = 0
	// Interpolate as `null` if no value is available.
	OperationInputRef_INTERPOLATION_NULL OperationInputRef_Interpolation = 1
	// Interpolate from the most recent row for the key if no value is
	// available.
	OperationInputRef_INTERPOLATION_AS_OF OperationInputRef_Interpolation = 2
)

// Enum value maps for OperationInputRef_Interpolation.
var (
	OperationInputRef_Interpolation_name = map[int32]string{
		0: "INTERPOLATION_UNSPECIFIED",
		1: "INTERPOLATION_NULL",
		2: "INTERPOLATION_AS_OF",
	}
	OperationInputRef_Interpolation_value = map[string]int32{
		"INTERPOLATION_UNSPECIFIED": 0,
		"INTERPOLATION_NULL":        1,
		"INTERPOLATION_AS_OF":       2,
	}
)

func (x OperationInputRef_Interpolation) Enum() *OperationInputRef_Interpolation {
	p := new(OperationInputRef_Interpolation)
	*p = x
	return p
}

func (x OperationInputRef_Interpolation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OperationInputRef_Interpolation) Descriptor() protoreflect.EnumDescriptor {
	return file_kaskada_kaskada_v1alpha_plan_proto_enumTypes[3].Descriptor()
}

func (OperationInputRef_Interpolation) Type() protoreflect.EnumType {
	return &file_kaskada_kaskada_v1alpha_plan_proto_enumTypes[3]
}

func (x OperationInputRef_Interpolation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OperationInputRef_Interpolation.Descriptor instead.
func (OperationInputRef_Interpolation) EnumDescriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{4, 1}
}

type ComputePlan struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PerEntityBehavior PerEntityBehavior `protobuf:"varint,1,opt,name=per_entity_behavior,json=perEntityBehavior,proto3,enum=kaskada.kaskada.v1alpha.PerEntityBehavior" json:"per_entity_behavior,omitempty"`
	// Topologically ordered operations to execute.
	//
	// Each operation is executed with a separate work area, since
	// the domain (rows) of the operation may differ) from other
	// operations.
	Operations []*OperationPlan `protobuf:"bytes,2,rep,name=operations,proto3" json:"operations,omitempty"`
	// The name of the grouping associated with the query.
	//
	// All of the tables used directly in the query (not via lookup)
	// must have this grouping.
	//
	// All entity keys occurring within the results of a query must
	// come from tables associated with this grouping.
	PrimaryGrouping string `protobuf:"bytes,3,opt,name=primary_grouping,json=primaryGrouping,proto3" json:"primary_grouping,omitempty"`
	// The key type of the primary grouping.
	PrimaryGroupingKeyType *DataType `protobuf:"bytes,4,opt,name=primary_grouping_key_type,json=primaryGroupingKeyType,proto3" json:"primary_grouping_key_type,omitempty"`
}

func (x *ComputePlan) Reset() {
	*x = ComputePlan{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ComputePlan) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComputePlan) ProtoMessage() {}

func (x *ComputePlan) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComputePlan.ProtoReflect.Descriptor instead.
func (*ComputePlan) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{0}
}

func (x *ComputePlan) GetPerEntityBehavior() PerEntityBehavior {
	if x != nil {
		return x.PerEntityBehavior
	}
	return PerEntityBehavior_PER_ENTITY_BEHAVIOR_UNSPECIFIED
}

func (x *ComputePlan) GetOperations() []*OperationPlan {
	if x != nil {
		return x.Operations
	}
	return nil
}

func (x *ComputePlan) GetPrimaryGrouping() string {
	if x != nil {
		return x.PrimaryGrouping
	}
	return ""
}

func (x *ComputePlan) GetPrimaryGroupingKeyType() *DataType {
	if x != nil {
		return x.PrimaryGroupingKeyType
	}
	return nil
}

type OperationPlan struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Expressions []*ExpressionPlan `protobuf:"bytes,1,rep,name=expressions,proto3" json:"expressions,omitempty"`
	// Types that are assignable to Operator:
	//	*OperationPlan_Scan
	//	*OperationPlan_Merge
	//	*OperationPlan_Select
	//	*OperationPlan_Tick
	//	*OperationPlan_WithKey
	//	*OperationPlan_LookupRequest
	//	*OperationPlan_LookupResponse
	//	*OperationPlan_ShiftTo
	//	*OperationPlan_ShiftUntil
	Operator isOperationPlan_Operator `protobuf_oneof:"operator"`
}

func (x *OperationPlan) Reset() {
	*x = OperationPlan{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OperationPlan) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationPlan) ProtoMessage() {}

func (x *OperationPlan) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationPlan.ProtoReflect.Descriptor instead.
func (*OperationPlan) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{1}
}

func (x *OperationPlan) GetExpressions() []*ExpressionPlan {
	if x != nil {
		return x.Expressions
	}
	return nil
}

func (m *OperationPlan) GetOperator() isOperationPlan_Operator {
	if m != nil {
		return m.Operator
	}
	return nil
}

func (x *OperationPlan) GetScan() *OperationPlan_ScanOperation {
	if x, ok := x.GetOperator().(*OperationPlan_Scan); ok {
		return x.Scan
	}
	return nil
}

func (x *OperationPlan) GetMerge() *OperationPlan_MergeOperation {
	if x, ok := x.GetOperator().(*OperationPlan_Merge); ok {
		return x.Merge
	}
	return nil
}

func (x *OperationPlan) GetSelect() *OperationPlan_SelectOperation {
	if x, ok := x.GetOperator().(*OperationPlan_Select); ok {
		return x.Select
	}
	return nil
}

func (x *OperationPlan) GetTick() *OperationPlan_TickOperation {
	if x, ok := x.GetOperator().(*OperationPlan_Tick); ok {
		return x.Tick
	}
	return nil
}

func (x *OperationPlan) GetWithKey() *OperationPlan_WithKeyOperation {
	if x, ok := x.GetOperator().(*OperationPlan_WithKey); ok {
		return x.WithKey
	}
	return nil
}

func (x *OperationPlan) GetLookupRequest() *OperationPlan_LookupRequestOperation {
	if x, ok := x.GetOperator().(*OperationPlan_LookupRequest); ok {
		return x.LookupRequest
	}
	return nil
}

func (x *OperationPlan) GetLookupResponse() *OperationPlan_LookupResponseOperation {
	if x, ok := x.GetOperator().(*OperationPlan_LookupResponse); ok {
		return x.LookupResponse
	}
	return nil
}

func (x *OperationPlan) GetShiftTo() *OperationPlan_ShiftToOperation {
	if x, ok := x.GetOperator().(*OperationPlan_ShiftTo); ok {
		return x.ShiftTo
	}
	return nil
}

func (x *OperationPlan) GetShiftUntil() *OperationPlan_ShiftUntilOperation {
	if x, ok := x.GetOperator().(*OperationPlan_ShiftUntil); ok {
		return x.ShiftUntil
	}
	return nil
}

type isOperationPlan_Operator interface {
	isOperationPlan_Operator()
}

type OperationPlan_Scan struct {
	// Should have no arguments.
	Scan *OperationPlan_ScanOperation `protobuf:"bytes,2,opt,name=scan,proto3,oneof"`
}

type OperationPlan_Merge struct {
	Merge *OperationPlan_MergeOperation `protobuf:"bytes,3,opt,name=merge,proto3,oneof"`
}

type OperationPlan_Select struct {
	Select *OperationPlan_SelectOperation `protobuf:"bytes,4,opt,name=select,proto3,oneof"`
}

type OperationPlan_Tick struct {
	Tick *OperationPlan_TickOperation `protobuf:"bytes,5,opt,name=tick,proto3,oneof"`
}

type OperationPlan_WithKey struct {
	WithKey *OperationPlan_WithKeyOperation `protobuf:"bytes,6,opt,name=with_key,json=withKey,proto3,oneof"`
}

type OperationPlan_LookupRequest struct {
	// A lookup request converts from primary to foreign domain.
	// The primary subsort and key are retained to enable sending the response.
	LookupRequest *OperationPlan_LookupRequestOperation `protobuf:"bytes,7,opt,name=lookup_request,json=lookupRequest,proto3,oneof"`
}

type OperationPlan_LookupResponse struct {
	// A lookup response converts from foreign back to primary domain.
	// The subsort and key are determined from retained columns.
	LookupResponse *OperationPlan_LookupResponseOperation `protobuf:"bytes,8,opt,name=lookup_response,json=lookupResponse,proto3,oneof"`
}

type OperationPlan_ShiftTo struct {
	ShiftTo *OperationPlan_ShiftToOperation `protobuf:"bytes,9,opt,name=shift_to,json=shiftTo,proto3,oneof"`
}

type OperationPlan_ShiftUntil struct {
	ShiftUntil *OperationPlan_ShiftUntilOperation `protobuf:"bytes,10,opt,name=shift_until,json=shiftUntil,proto3,oneof"`
}

func (*OperationPlan_Scan) isOperationPlan_Operator() {}

func (*OperationPlan_Merge) isOperationPlan_Operator() {}

func (*OperationPlan_Select) isOperationPlan_Operator() {}

func (*OperationPlan_Tick) isOperationPlan_Operator() {}

func (*OperationPlan_WithKey) isOperationPlan_Operator() {}

func (*OperationPlan_LookupRequest) isOperationPlan_Operator() {}

func (*OperationPlan_LookupResponse) isOperationPlan_Operator() {}

func (*OperationPlan_ShiftTo) isOperationPlan_Operator() {}

func (*OperationPlan_ShiftUntil) isOperationPlan_Operator() {}

type ExpressionPlan struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Each argument references an expression from the operation.
	Arguments  []uint32  `protobuf:"varint,1,rep,packed,name=arguments,proto3" json:"arguments,omitempty"`
	ResultType *DataType `protobuf:"bytes,2,opt,name=result_type,json=resultType,proto3" json:"result_type,omitempty"`
	// If true, the column computed by this expression should be included in
	// the output of the operation.
	Output bool `protobuf:"varint,3,opt,name=output,proto3" json:"output,omitempty"`
	// The operator this step applies.
	//
	// Types that are assignable to Operator:
	//	*ExpressionPlan_Instruction
	//	*ExpressionPlan_Input
	//	*ExpressionPlan_Literal
	//	*ExpressionPlan_LateBound
	Operator isExpressionPlan_Operator `protobuf_oneof:"operator"`
}

func (x *ExpressionPlan) Reset() {
	*x = ExpressionPlan{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExpressionPlan) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExpressionPlan) ProtoMessage() {}

func (x *ExpressionPlan) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExpressionPlan.ProtoReflect.Descriptor instead.
func (*ExpressionPlan) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{2}
}

func (x *ExpressionPlan) GetArguments() []uint32 {
	if x != nil {
		return x.Arguments
	}
	return nil
}

func (x *ExpressionPlan) GetResultType() *DataType {
	if x != nil {
		return x.ResultType
	}
	return nil
}

func (x *ExpressionPlan) GetOutput() bool {
	if x != nil {
		return x.Output
	}
	return false
}

func (m *ExpressionPlan) GetOperator() isExpressionPlan_Operator {
	if m != nil {
		return m.Operator
	}
	return nil
}

func (x *ExpressionPlan) GetInstruction() string {
	if x, ok := x.GetOperator().(*ExpressionPlan_Instruction); ok {
		return x.Instruction
	}
	return ""
}

func (x *ExpressionPlan) GetInput() *OperationInputRef {
	if x, ok := x.GetOperator().(*ExpressionPlan_Input); ok {
		return x.Input
	}
	return nil
}

func (x *ExpressionPlan) GetLiteral() *Literal {
	if x, ok := x.GetOperator().(*ExpressionPlan_Literal); ok {
		return x.Literal
	}
	return nil
}

func (x *ExpressionPlan) GetLateBound() LateBoundValue {
	if x, ok := x.GetOperator().(*ExpressionPlan_LateBound); ok {
		return x.LateBound
	}
	return LateBoundValue_LATE_BOUND_VALUE_UNSPECIFIED
}

type isExpressionPlan_Operator interface {
	isExpressionPlan_Operator()
}

type ExpressionPlan_Instruction struct {
	// Applies a named operator.
	Instruction string `protobuf:"bytes,4,opt,name=instruction,proto3,oneof"`
}

type ExpressionPlan_Input struct {
	// References one of the inputs to the operation.
	Input *OperationInputRef `protobuf:"bytes,5,opt,name=input,proto3,oneof"`
}

type ExpressionPlan_Literal struct {
	Literal *Literal `protobuf:"bytes,6,opt,name=literal,proto3,oneof"`
}

type ExpressionPlan_LateBound struct {
	LateBound LateBoundValue `protobuf:"varint,7,opt,name=late_bound,json=lateBound,proto3,enum=kaskada.kaskada.v1alpha.LateBoundValue,oneof"`
}

func (*ExpressionPlan_Instruction) isExpressionPlan_Operator() {}

func (*ExpressionPlan_Input) isExpressionPlan_Operator() {}

func (*ExpressionPlan_Literal) isExpressionPlan_Operator() {}

func (*ExpressionPlan_LateBound) isExpressionPlan_Operator() {}

type Literal struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// TODO: Better ScalarValue proto encoding
	//
	// Types that are assignable to Literal:
	//	*Literal_Bool
	//	*Literal_Int8
	//	*Literal_Int16
	//	*Literal_Int32
	//	*Literal_Int64
	//	*Literal_Uint8
	//	*Literal_Uint16
	//	*Literal_Uint32
	//	*Literal_Uint64
	//	*Literal_Float32
	//	*Literal_Float64
	//	*Literal_Timestamp
	//	*Literal_Date32
	//	*Literal_Date64
	//	*Literal_Time32
	//	*Literal_Time64
	//	*Literal_Duration
	//	*Literal_IntervalDayTime
	//	*Literal_IntervalMonths
	//	*Literal_Utf8
	//	*Literal_Record
	Literal isLiteral_Literal `protobuf_oneof:"literal"`
}

func (x *Literal) Reset() {
	*x = Literal{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Literal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Literal) ProtoMessage() {}

func (x *Literal) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Literal.ProtoReflect.Descriptor instead.
func (*Literal) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{3}
}

func (m *Literal) GetLiteral() isLiteral_Literal {
	if m != nil {
		return m.Literal
	}
	return nil
}

func (x *Literal) GetBool() bool {
	if x, ok := x.GetLiteral().(*Literal_Bool); ok {
		return x.Bool
	}
	return false
}

func (x *Literal) GetInt8() int32 {
	if x, ok := x.GetLiteral().(*Literal_Int8); ok {
		return x.Int8
	}
	return 0
}

func (x *Literal) GetInt16() int32 {
	if x, ok := x.GetLiteral().(*Literal_Int16); ok {
		return x.Int16
	}
	return 0
}

func (x *Literal) GetInt32() int32 {
	if x, ok := x.GetLiteral().(*Literal_Int32); ok {
		return x.Int32
	}
	return 0
}

func (x *Literal) GetInt64() int64 {
	if x, ok := x.GetLiteral().(*Literal_Int64); ok {
		return x.Int64
	}
	return 0
}

func (x *Literal) GetUint8() uint32 {
	if x, ok := x.GetLiteral().(*Literal_Uint8); ok {
		return x.Uint8
	}
	return 0
}

func (x *Literal) GetUint16() uint32 {
	if x, ok := x.GetLiteral().(*Literal_Uint16); ok {
		return x.Uint16
	}
	return 0
}

func (x *Literal) GetUint32() uint32 {
	if x, ok := x.GetLiteral().(*Literal_Uint32); ok {
		return x.Uint32
	}
	return 0
}

func (x *Literal) GetUint64() uint64 {
	if x, ok := x.GetLiteral().(*Literal_Uint64); ok {
		return x.Uint64
	}
	return 0
}

func (x *Literal) GetFloat32() float32 {
	if x, ok := x.GetLiteral().(*Literal_Float32); ok {
		return x.Float32
	}
	return 0
}

func (x *Literal) GetFloat64() float64 {
	if x, ok := x.GetLiteral().(*Literal_Float64); ok {
		return x.Float64
	}
	return 0
}

func (x *Literal) GetTimestamp() *Literal_TimestampValue {
	if x, ok := x.GetLiteral().(*Literal_Timestamp); ok {
		return x.Timestamp
	}
	return nil
}

func (x *Literal) GetDate32() int32 {
	if x, ok := x.GetLiteral().(*Literal_Date32); ok {
		return x.Date32
	}
	return 0
}

func (x *Literal) GetDate64() int64 {
	if x, ok := x.GetLiteral().(*Literal_Date64); ok {
		return x.Date64
	}
	return 0
}

func (x *Literal) GetTime32() *Literal_Time32Value {
	if x, ok := x.GetLiteral().(*Literal_Time32); ok {
		return x.Time32
	}
	return nil
}

func (x *Literal) GetTime64() *Literal_Time64Value {
	if x, ok := x.GetLiteral().(*Literal_Time64); ok {
		return x.Time64
	}
	return nil
}

func (x *Literal) GetDuration() *Literal_DurationValue {
	if x, ok := x.GetLiteral().(*Literal_Duration); ok {
		return x.Duration
	}
	return nil
}

func (x *Literal) GetIntervalDayTime() *Literal_IntervalDayTimeValue {
	if x, ok := x.GetLiteral().(*Literal_IntervalDayTime); ok {
		return x.IntervalDayTime
	}
	return nil
}

func (x *Literal) GetIntervalMonths() int32 {
	if x, ok := x.GetLiteral().(*Literal_IntervalMonths); ok {
		return x.IntervalMonths
	}
	return 0
}

func (x *Literal) GetUtf8() string {
	if x, ok := x.GetLiteral().(*Literal_Utf8); ok {
		return x.Utf8
	}
	return ""
}

func (x *Literal) GetRecord() *Literal_RecordValue {
	if x, ok := x.GetLiteral().(*Literal_Record); ok {
		return x.Record
	}
	return nil
}

type isLiteral_Literal interface {
	isLiteral_Literal()
}

type Literal_Bool struct {
	Bool bool `protobuf:"varint,8,opt,name=bool,proto3,oneof"`
}

type Literal_Int8 struct {
	Int8 int32 `protobuf:"varint,9,opt,name=int8,proto3,oneof"`
}

type Literal_Int16 struct {
	Int16 int32 `protobuf:"varint,10,opt,name=int16,proto3,oneof"`
}

type Literal_Int32 struct {
	Int32 int32 `protobuf:"varint,11,opt,name=int32,proto3,oneof"`
}

type Literal_Int64 struct {
	Int64 int64 `protobuf:"varint,12,opt,name=int64,proto3,oneof"`
}

type Literal_Uint8 struct {
	Uint8 uint32 `protobuf:"varint,13,opt,name=uint8,proto3,oneof"`
}

type Literal_Uint16 struct {
	Uint16 uint32 `protobuf:"varint,14,opt,name=uint16,proto3,oneof"`
}

type Literal_Uint32 struct {
	Uint32 uint32 `protobuf:"varint,15,opt,name=uint32,proto3,oneof"`
}

type Literal_Uint64 struct {
	Uint64 uint64 `protobuf:"varint,16,opt,name=uint64,proto3,oneof"`
}

type Literal_Float32 struct {
	Float32 float32 `protobuf:"fixed32,17,opt,name=float32,proto3,oneof"`
}

type Literal_Float64 struct {
	Float64 float64 `protobuf:"fixed64,18,opt,name=float64,proto3,oneof"`
}

type Literal_Timestamp struct {
	Timestamp *Literal_TimestampValue `protobuf:"bytes,19,opt,name=timestamp,proto3,oneof"`
}

type Literal_Date32 struct {
	Date32 int32 `protobuf:"varint,20,opt,name=date32,proto3,oneof"`
}

type Literal_Date64 struct {
	Date64 int64 `protobuf:"varint,21,opt,name=date64,proto3,oneof"`
}

type Literal_Time32 struct {
	Time32 *Literal_Time32Value `protobuf:"bytes,22,opt,name=time32,proto3,oneof"`
}

type Literal_Time64 struct {
	Time64 *Literal_Time64Value `protobuf:"bytes,23,opt,name=time64,proto3,oneof"`
}

type Literal_Duration struct {
	Duration *Literal_DurationValue `protobuf:"bytes,24,opt,name=duration,proto3,oneof"`
}

type Literal_IntervalDayTime struct {
	IntervalDayTime *Literal_IntervalDayTimeValue `protobuf:"bytes,25,opt,name=interval_day_time,json=intervalDayTime,proto3,oneof"`
}

type Literal_IntervalMonths struct {
	IntervalMonths int32 `protobuf:"varint,26,opt,name=interval_months,json=intervalMonths,proto3,oneof"`
}

type Literal_Utf8 struct {
	Utf8 string `protobuf:"bytes,27,opt,name=utf8,proto3,oneof"`
}

type Literal_Record struct {
	Record *Literal_RecordValue `protobuf:"bytes,28,opt,name=record,proto3,oneof"`
}

func (*Literal_Bool) isLiteral_Literal() {}

func (*Literal_Int8) isLiteral_Literal() {}

func (*Literal_Int16) isLiteral_Literal() {}

func (*Literal_Int32) isLiteral_Literal() {}

func (*Literal_Int64) isLiteral_Literal() {}

func (*Literal_Uint8) isLiteral_Literal() {}

func (*Literal_Uint16) isLiteral_Literal() {}

func (*Literal_Uint32) isLiteral_Literal() {}

func (*Literal_Uint64) isLiteral_Literal() {}

func (*Literal_Float32) isLiteral_Literal() {}

func (*Literal_Float64) isLiteral_Literal() {}

func (*Literal_Timestamp) isLiteral_Literal() {}

func (*Literal_Date32) isLiteral_Literal() {}

func (*Literal_Date64) isLiteral_Literal() {}

func (*Literal_Time32) isLiteral_Literal() {}

func (*Literal_Time64) isLiteral_Literal() {}

func (*Literal_Duration) isLiteral_Literal() {}

func (*Literal_IntervalDayTime) isLiteral_Literal() {}

func (*Literal_IntervalMonths) isLiteral_Literal() {}

func (*Literal_Utf8) isLiteral_Literal() {}

func (*Literal_Record) isLiteral_Literal() {}

// References one of the inputs to the operation.
//
// These refer to an input based on the producing operation and expression.
//
// One notable exception is the scan operation which has exactly one input
// corresponding to the records read from the table. It uses it's own index
// as the `producing_operation` (indicating that it "inputs from itself") and
// `producing_expression = 0` (as expression 0) to indicate the rows being
// read.
type OperationInputRef struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The index of the producing operation within the compute plan.
	// This index should be one of the `consumed_operation_indices` for this operation.
	ProducingOperation uint32 `protobuf:"varint,1,opt,name=producing_operation,json=producingOperation,proto3" json:"producing_operation,omitempty"`
	// Types that are assignable to Column:
	//	*OperationInputRef_KeyColumn_
	//	*OperationInputRef_ProducerExpression
	//	*OperationInputRef_ScanRecord
	//	*OperationInputRef_Tick
	Column isOperationInputRef_Column `protobuf_oneof:"column"`
	// The index of the referenced column in the producing operation's output.
	//
	// * 0 = time,
	// * 1 = subsort,
	// * 2 = key_hash,
	// * 3 = first output column,
	// * 4 = second output column,
	// * ...
	InputColumn   uint32                          `protobuf:"varint,5,opt,name=input_column,json=inputColumn,proto3" json:"input_column,omitempty"`
	Interpolation OperationInputRef_Interpolation `protobuf:"varint,6,opt,name=interpolation,proto3,enum=kaskada.kaskada.v1alpha.OperationInputRef_Interpolation" json:"interpolation,omitempty"`
}

func (x *OperationInputRef) Reset() {
	*x = OperationInputRef{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OperationInputRef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationInputRef) ProtoMessage() {}

func (x *OperationInputRef) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationInputRef.ProtoReflect.Descriptor instead.
func (*OperationInputRef) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{4}
}

func (x *OperationInputRef) GetProducingOperation() uint32 {
	if x != nil {
		return x.ProducingOperation
	}
	return 0
}

func (m *OperationInputRef) GetColumn() isOperationInputRef_Column {
	if m != nil {
		return m.Column
	}
	return nil
}

func (x *OperationInputRef) GetKeyColumn() OperationInputRef_KeyColumn {
	if x, ok := x.GetColumn().(*OperationInputRef_KeyColumn_); ok {
		return x.KeyColumn
	}
	return OperationInputRef_KEY_COLUMN_UNSPECIFIED
}

func (x *OperationInputRef) GetProducerExpression() uint32 {
	if x, ok := x.GetColumn().(*OperationInputRef_ProducerExpression); ok {
		return x.ProducerExpression
	}
	return 0
}

func (x *OperationInputRef) GetScanRecord() *emptypb.Empty {
	if x, ok := x.GetColumn().(*OperationInputRef_ScanRecord); ok {
		return x.ScanRecord
	}
	return nil
}

func (x *OperationInputRef) GetTick() *emptypb.Empty {
	if x, ok := x.GetColumn().(*OperationInputRef_Tick); ok {
		return x.Tick
	}
	return nil
}

func (x *OperationInputRef) GetInputColumn() uint32 {
	if x != nil {
		return x.InputColumn
	}
	return 0
}

func (x *OperationInputRef) GetInterpolation() OperationInputRef_Interpolation {
	if x != nil {
		return x.Interpolation
	}
	return OperationInputRef_INTERPOLATION_UNSPECIFIED
}

type isOperationInputRef_Column interface {
	isOperationInputRef_Column()
}

type OperationInputRef_KeyColumn_ struct {
	KeyColumn OperationInputRef_KeyColumn `protobuf:"varint,2,opt,name=key_column,json=keyColumn,proto3,enum=kaskada.kaskada.v1alpha.OperationInputRef_KeyColumn,oneof"`
}

type OperationInputRef_ProducerExpression struct {
	// Reference the result of this expression within the producer.
	//
	// The referenced expression must be marked as on output expression.
	ProducerExpression uint32 `protobuf:"varint,3,opt,name=producer_expression,json=producerExpression,proto3,oneof"`
}

type OperationInputRef_ScanRecord struct {
	// Indicates that this is referencing the scanned record.
	ScanRecord *emptypb.Empty `protobuf:"bytes,4,opt,name=scan_record,json=scanRecord,proto3,oneof"`
}

type OperationInputRef_Tick struct {
	// Indicates that this is referencing the tick column.
	Tick *emptypb.Empty `protobuf:"bytes,7,opt,name=tick,proto3,oneof"`
}

func (*OperationInputRef_KeyColumn_) isOperationInputRef_Column() {}

func (*OperationInputRef_ProducerExpression) isOperationInputRef_Column() {}

func (*OperationInputRef_ScanRecord) isOperationInputRef_Column() {}

func (*OperationInputRef_Tick) isOperationInputRef_Column() {}

type OperationPlan_ScanOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TableId *Uuid `protobuf:"bytes,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// The (projected) table schema.
	//
	// When used within Sparrow, we should take care to convert this to
	// a SchemaRef once to avoid creating multiple copies of it.
	Schema    *Schema    `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
	SlicePlan *SlicePlan `protobuf:"bytes,3,opt,name=slice_plan,json=slicePlan,proto3" json:"slice_plan,omitempty"`
}

func (x *OperationPlan_ScanOperation) Reset() {
	*x = OperationPlan_ScanOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OperationPlan_ScanOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationPlan_ScanOperation) ProtoMessage() {}

func (x *OperationPlan_ScanOperation) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationPlan_ScanOperation.ProtoReflect.Descriptor instead.
func (*OperationPlan_ScanOperation) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{1, 0}
}

func (x *OperationPlan_ScanOperation) GetTableId() *Uuid {
	if x != nil {
		return x.TableId
	}
	return nil
}

func (x *OperationPlan_ScanOperation) GetSchema() *Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

func (x *OperationPlan_ScanOperation) GetSlicePlan() *SlicePlan {
	if x != nil {
		return x.SlicePlan
	}
	return nil
}

type OperationPlan_MergeOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Index of the left operation.
	Left uint32 `protobuf:"varint,1,opt,name=left,proto3" json:"left,omitempty"`
	// Index of the right operation.
	Right uint32 `protobuf:"varint,2,opt,name=right,proto3" json:"right,omitempty"`
}

func (x *OperationPlan_MergeOperation) Reset() {
	*x = OperationPlan_MergeOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OperationPlan_MergeOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationPlan_MergeOperation) ProtoMessage() {}

func (x *OperationPlan_MergeOperation) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationPlan_MergeOperation.ProtoReflect.Descriptor instead.
func (*OperationPlan_MergeOperation) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{1, 1}
}

func (x *OperationPlan_MergeOperation) GetLeft() uint32 {
	if x != nil {
		return x.Left
	}
	return 0
}

func (x *OperationPlan_MergeOperation) GetRight() uint32 {
	if x != nil {
		return x.Right
	}
	return 0
}

type OperationPlan_SelectOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Index of the operation that the select reads from.
	Input uint32 `protobuf:"varint,1,opt,name=input,proto3" json:"input,omitempty"`
	// Reference to the operation input representing the condition.
	Condition *OperationInputRef `protobuf:"bytes,2,opt,name=condition,proto3" json:"condition,omitempty"`
}

func (x *OperationPlan_SelectOperation) Reset() {
	*x = OperationPlan_SelectOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OperationPlan_SelectOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationPlan_SelectOperation) ProtoMessage() {}

func (x *OperationPlan_SelectOperation) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationPlan_SelectOperation.ProtoReflect.Descriptor instead.
func (*OperationPlan_SelectOperation) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{1, 2}
}

func (x *OperationPlan_SelectOperation) GetInput() uint32 {
	if x != nil {
		return x.Input
	}
	return 0
}

func (x *OperationPlan_SelectOperation) GetCondition() *OperationInputRef {
	if x != nil {
		return x.Condition
	}
	return nil
}

type OperationPlan_WithKeyOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Index of the operation that the with_key reads from.
	Input uint32 `protobuf:"varint,1,opt,name=input,proto3" json:"input,omitempty"`
	// Reference to the operation input representing the new key column.
	NewKey *OperationInputRef `protobuf:"bytes,2,opt,name=new_key,json=newKey,proto3" json:"new_key,omitempty"`
	// The name of the grouping this operation produces.
	Grouping string `protobuf:"bytes,3,opt,name=grouping,proto3" json:"grouping,omitempty"`
}

func (x *OperationPlan_WithKeyOperation) Reset() {
	*x = OperationPlan_WithKeyOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OperationPlan_WithKeyOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationPlan_WithKeyOperation) ProtoMessage() {}

func (x *OperationPlan_WithKeyOperation) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationPlan_WithKeyOperation.ProtoReflect.Descriptor instead.
func (*OperationPlan_WithKeyOperation) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{1, 3}
}

func (x *OperationPlan_WithKeyOperation) GetInput() uint32 {
	if x != nil {
		return x.Input
	}
	return 0
}

func (x *OperationPlan_WithKeyOperation) GetNewKey() *OperationInputRef {
	if x != nil {
		return x.NewKey
	}
	return nil
}

func (x *OperationPlan_WithKeyOperation) GetGrouping() string {
	if x != nil {
		return x.Grouping
	}
	return ""
}

type OperationPlan_TickOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Describes the times this operation will tick over.
	//
	// Note that while this currently only allows for producing a single
	// tick column, a good evolution would be to recognize when multiple
	// tick behaviors are going to be merged together, and allow for this
	// operation to accept repeated tick behavior, doing the merge
	// pre-emptively.
	Behavior OperationPlan_TickOperation_TickBehavior `protobuf:"varint,1,opt,name=behavior,proto3,enum=kaskada.kaskada.v1alpha.OperationPlan_TickOperation_TickBehavior" json:"behavior,omitempty"`
	// Index of the operation that the tick reads from.
	//
	// The domain (keys) of this operation are determined from the input
	// operation.
	Input uint32 `protobuf:"varint,2,opt,name=input,proto3" json:"input,omitempty"`
}

func (x *OperationPlan_TickOperation) Reset() {
	*x = OperationPlan_TickOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OperationPlan_TickOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationPlan_TickOperation) ProtoMessage() {}

func (x *OperationPlan_TickOperation) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationPlan_TickOperation.ProtoReflect.Descriptor instead.
func (*OperationPlan_TickOperation) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{1, 4}
}

func (x *OperationPlan_TickOperation) GetBehavior() OperationPlan_TickOperation_TickBehavior {
	if x != nil {
		return x.Behavior
	}
	return OperationPlan_TickOperation_TICK_BEHAVIOR_UNSPECIFIED
}

func (x *OperationPlan_TickOperation) GetInput() uint32 {
	if x != nil {
		return x.Input
	}
	return 0
}

type OperationPlan_LookupRequestOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Index of the operation this LookupRequest reads from.
	PrimaryOperation uint32 `protobuf:"varint,1,opt,name=primary_operation,json=primaryOperation,proto3" json:"primary_operation,omitempty"`
	// The expression that contains the foreign key hash.
	ForeignKeyHash *OperationInputRef `protobuf:"bytes,2,opt,name=foreign_key_hash,json=foreignKeyHash,proto3" json:"foreign_key_hash,omitempty"`
}

func (x *OperationPlan_LookupRequestOperation) Reset() {
	*x = OperationPlan_LookupRequestOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OperationPlan_LookupRequestOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationPlan_LookupRequestOperation) ProtoMessage() {}

func (x *OperationPlan_LookupRequestOperation) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationPlan_LookupRequestOperation.ProtoReflect.Descriptor instead.
func (*OperationPlan_LookupRequestOperation) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{1, 5}
}

func (x *OperationPlan_LookupRequestOperation) GetPrimaryOperation() uint32 {
	if x != nil {
		return x.PrimaryOperation
	}
	return 0
}

func (x *OperationPlan_LookupRequestOperation) GetForeignKeyHash() *OperationInputRef {
	if x != nil {
		return x.ForeignKeyHash
	}
	return nil
}

type OperationPlan_LookupResponseOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Index of the operation this LookupResponse reads from.
	ForeignOperation uint32 `protobuf:"varint,1,opt,name=foreign_operation,json=foreignOperation,proto3" json:"foreign_operation,omitempty"`
	// Reference to the requesting key column in the `foreign_operation`.
	RequestingKeyHash *OperationInputRef `protobuf:"bytes,2,opt,name=requesting_key_hash,json=requestingKeyHash,proto3" json:"requesting_key_hash,omitempty"`
}

func (x *OperationPlan_LookupResponseOperation) Reset() {
	*x = OperationPlan_LookupResponseOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OperationPlan_LookupResponseOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationPlan_LookupResponseOperation) ProtoMessage() {}

func (x *OperationPlan_LookupResponseOperation) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationPlan_LookupResponseOperation.ProtoReflect.Descriptor instead.
func (*OperationPlan_LookupResponseOperation) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{1, 6}
}

func (x *OperationPlan_LookupResponseOperation) GetForeignOperation() uint32 {
	if x != nil {
		return x.ForeignOperation
	}
	return 0
}

func (x *OperationPlan_LookupResponseOperation) GetRequestingKeyHash() *OperationInputRef {
	if x != nil {
		return x.RequestingKeyHash
	}
	return nil
}

type OperationPlan_ShiftToOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Input uint32 `protobuf:"varint,1,opt,name=input,proto3" json:"input,omitempty"`
	// Types that are assignable to Time:
	//	*OperationPlan_ShiftToOperation_Computed
	//	*OperationPlan_ShiftToOperation_Literal
	Time isOperationPlan_ShiftToOperation_Time `protobuf_oneof:"time"`
}

func (x *OperationPlan_ShiftToOperation) Reset() {
	*x = OperationPlan_ShiftToOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OperationPlan_ShiftToOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationPlan_ShiftToOperation) ProtoMessage() {}

func (x *OperationPlan_ShiftToOperation) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationPlan_ShiftToOperation.ProtoReflect.Descriptor instead.
func (*OperationPlan_ShiftToOperation) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{1, 7}
}

func (x *OperationPlan_ShiftToOperation) GetInput() uint32 {
	if x != nil {
		return x.Input
	}
	return 0
}

func (m *OperationPlan_ShiftToOperation) GetTime() isOperationPlan_ShiftToOperation_Time {
	if m != nil {
		return m.Time
	}
	return nil
}

func (x *OperationPlan_ShiftToOperation) GetComputed() *OperationInputRef {
	if x, ok := x.GetTime().(*OperationPlan_ShiftToOperation_Computed); ok {
		return x.Computed
	}
	return nil
}

func (x *OperationPlan_ShiftToOperation) GetLiteral() *timestamppb.Timestamp {
	if x, ok := x.GetTime().(*OperationPlan_ShiftToOperation_Literal); ok {
		return x.Literal
	}
	return nil
}

type isOperationPlan_ShiftToOperation_Time interface {
	isOperationPlan_ShiftToOperation_Time()
}

type OperationPlan_ShiftToOperation_Computed struct {
	// Shift inputs to the corresponding computed time.
	Computed *OperationInputRef `protobuf:"bytes,2,opt,name=computed,proto3,oneof"`
}

type OperationPlan_ShiftToOperation_Literal struct {
	// Shift inputs to the given fixed timestamp.
	Literal *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=literal,proto3,oneof"`
}

func (*OperationPlan_ShiftToOperation_Computed) isOperationPlan_ShiftToOperation_Time() {}

func (*OperationPlan_ShiftToOperation_Literal) isOperationPlan_ShiftToOperation_Time() {}

type OperationPlan_ShiftUntilOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Input     uint32             `protobuf:"varint,1,opt,name=input,proto3" json:"input,omitempty"`
	Condition *OperationInputRef `protobuf:"bytes,2,opt,name=condition,proto3" json:"condition,omitempty"`
}

func (x *OperationPlan_ShiftUntilOperation) Reset() {
	*x = OperationPlan_ShiftUntilOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OperationPlan_ShiftUntilOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationPlan_ShiftUntilOperation) ProtoMessage() {}

func (x *OperationPlan_ShiftUntilOperation) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationPlan_ShiftUntilOperation.ProtoReflect.Descriptor instead.
func (*OperationPlan_ShiftUntilOperation) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{1, 8}
}

func (x *OperationPlan_ShiftUntilOperation) GetInput() uint32 {
	if x != nil {
		return x.Input
	}
	return 0
}

func (x *OperationPlan_ShiftUntilOperation) GetCondition() *OperationInputRef {
	if x != nil {
		return x.Condition
	}
	return nil
}

type Literal_TimestampValue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Value *wrapperspb.Int64Value  `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Unit  string                  `protobuf:"bytes,2,opt,name=unit,proto3" json:"unit,omitempty"`
	Tz    *wrapperspb.StringValue `protobuf:"bytes,3,opt,name=tz,proto3" json:"tz,omitempty"`
}

func (x *Literal_TimestampValue) Reset() {
	*x = Literal_TimestampValue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Literal_TimestampValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Literal_TimestampValue) ProtoMessage() {}

func (x *Literal_TimestampValue) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Literal_TimestampValue.ProtoReflect.Descriptor instead.
func (*Literal_TimestampValue) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{3, 0}
}

func (x *Literal_TimestampValue) GetValue() *wrapperspb.Int64Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *Literal_TimestampValue) GetUnit() string {
	if x != nil {
		return x.Unit
	}
	return ""
}

func (x *Literal_TimestampValue) GetTz() *wrapperspb.StringValue {
	if x != nil {
		return x.Tz
	}
	return nil
}

type Literal_Time32Value struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Value int32  `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	Unit  string `protobuf:"bytes,2,opt,name=unit,proto3" json:"unit,omitempty"`
}

func (x *Literal_Time32Value) Reset() {
	*x = Literal_Time32Value{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Literal_Time32Value) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Literal_Time32Value) ProtoMessage() {}

func (x *Literal_Time32Value) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Literal_Time32Value.ProtoReflect.Descriptor instead.
func (*Literal_Time32Value) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{3, 1}
}

func (x *Literal_Time32Value) GetValue() int32 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *Literal_Time32Value) GetUnit() string {
	if x != nil {
		return x.Unit
	}
	return ""
}

type Literal_Time64Value struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Value int64  `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	Unit  string `protobuf:"bytes,2,opt,name=unit,proto3" json:"unit,omitempty"`
}

func (x *Literal_Time64Value) Reset() {
	*x = Literal_Time64Value{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Literal_Time64Value) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Literal_Time64Value) ProtoMessage() {}

func (x *Literal_Time64Value) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Literal_Time64Value.ProtoReflect.Descriptor instead.
func (*Literal_Time64Value) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{3, 2}
}

func (x *Literal_Time64Value) GetValue() int64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *Literal_Time64Value) GetUnit() string {
	if x != nil {
		return x.Unit
	}
	return ""
}

type Literal_DurationValue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Value int64  `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	Unit  string `protobuf:"bytes,2,opt,name=unit,proto3" json:"unit,omitempty"`
}

func (x *Literal_DurationValue) Reset() {
	*x = Literal_DurationValue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Literal_DurationValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Literal_DurationValue) ProtoMessage() {}

func (x *Literal_DurationValue) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Literal_DurationValue.ProtoReflect.Descriptor instead.
func (*Literal_DurationValue) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{3, 3}
}

func (x *Literal_DurationValue) GetValue() int64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *Literal_DurationValue) GetUnit() string {
	if x != nil {
		return x.Unit
	}
	return ""
}

type Literal_IntervalDayTimeValue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Start int32 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End   int32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (x *Literal_IntervalDayTimeValue) Reset() {
	*x = Literal_IntervalDayTimeValue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Literal_IntervalDayTimeValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Literal_IntervalDayTimeValue) ProtoMessage() {}

func (x *Literal_IntervalDayTimeValue) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Literal_IntervalDayTimeValue.ProtoReflect.Descriptor instead.
func (*Literal_IntervalDayTimeValue) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{3, 4}
}

func (x *Literal_IntervalDayTimeValue) GetStart() int32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *Literal_IntervalDayTimeValue) GetEnd() int32 {
	if x != nil {
		return x.End
	}
	return 0
}

type Literal_RecordValue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Values []*Literal `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
}

func (x *Literal_RecordValue) Reset() {
	*x = Literal_RecordValue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Literal_RecordValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Literal_RecordValue) ProtoMessage() {}

func (x *Literal_RecordValue) ProtoReflect() protoreflect.Message {
	mi := &file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Literal_RecordValue.ProtoReflect.Descriptor instead.
func (*Literal_RecordValue) Descriptor() ([]byte, []int) {
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP(), []int{3, 5}
}

func (x *Literal_RecordValue) GetValues() []*Literal {
	if x != nil {
		return x.Values
	}
	return nil
}

var File_kaskada_kaskada_v1alpha_plan_proto protoreflect.FileDescriptor

var file_kaskada_kaskada_v1alpha_plan_proto_rawDesc = []byte{
	0x0a, 0x22, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2f, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64,
	0x61, 0x2f, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2f, 0x70, 0x6c, 0x61, 0x6e, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x12, 0x17, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61,
	0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x1a, 0x1b, 0x67,
	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65,
	0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f, 0x6f,
	0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x77, 0x72, 0x61,
	0x70, 0x70, 0x65, 0x72, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x24, 0x6b, 0x61, 0x73,
	0x6b, 0x61, 0x64, 0x61, 0x2f, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2f, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x1a, 0x24, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2f, 0x6b, 0x61, 0x73, 0x6b, 0x61,
	0x64, 0x61, 0x2f, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2f, 0x73, 0x63, 0x68, 0x65, 0x6d,
	0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xba, 0x02, 0x0a, 0x0b, 0x43, 0x6f, 0x6d, 0x70,
	0x75, 0x74, 0x65, 0x50, 0x6c, 0x61, 0x6e, 0x12, 0x5a, 0x0a, 0x13, 0x70, 0x65, 0x72, 0x5f, 0x65,
	0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x2a, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x50,
	0x65, 0x72, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x42, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72,
	0x52, 0x11, 0x70, 0x65, 0x72, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x42, 0x65, 0x68, 0x61, 0x76,
	0x69, 0x6f, 0x72, 0x12, 0x46, 0x0a, 0x0a, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64,
	0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68,
	0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6c, 0x61, 0x6e, 0x52,
	0x0a, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x29, 0x0a, 0x10, 0x70,
	0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x5f, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x69, 0x6e, 0x67, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x70, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x47, 0x72,
	0x6f, 0x75, 0x70, 0x69, 0x6e, 0x67, 0x12, 0x5c, 0x0a, 0x19, 0x70, 0x72, 0x69, 0x6d, 0x61, 0x72,
	0x79, 0x5f, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x74,
	0x79, 0x70, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x54, 0x79, 0x70, 0x65, 0x52, 0x16, 0x70, 0x72,
	0x69, 0x6d, 0x61, 0x72, 0x79, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x69, 0x6e, 0x67, 0x4b, 0x65, 0x79,
	0x54, 0x79, 0x70, 0x65, 0x22, 0xc6, 0x12, 0x0a, 0x0d, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x50, 0x6c, 0x61, 0x6e, 0x12, 0x49, 0x0a, 0x0b, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73,
	0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x6b, 0x61,
	0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
	0x50, 0x6c, 0x61, 0x6e, 0x52, 0x0b, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
	0x73, 0x12, 0x4a, 0x0a, 0x04, 0x73, 0x63, 0x61, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x34, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64,
	0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x50, 0x6c, 0x61, 0x6e, 0x2e, 0x53, 0x63, 0x61, 0x6e, 0x4f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x04, 0x73, 0x63, 0x61, 0x6e, 0x12, 0x4d, 0x0a,
	0x05, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x6b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x50, 0x6c, 0x61, 0x6e, 0x2e, 0x4d, 0x65, 0x72, 0x67, 0x65, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x05, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x12, 0x50, 0x0a, 0x06,
	0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x36, 0x2e, 0x6b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x50, 0x6c, 0x61, 0x6e, 0x2e, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x4f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x06, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x12, 0x4a,
	0x0a, 0x04, 0x74, 0x69, 0x63, 0x6b, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x6b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x50, 0x6c, 0x61, 0x6e, 0x2e, 0x54, 0x69, 0x63, 0x6b, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x48, 0x00, 0x52, 0x04, 0x74, 0x69, 0x63, 0x6b, 0x12, 0x54, 0x0a, 0x08, 0x77, 0x69,
	0x74, 0x68, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x6b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x50, 0x6c, 0x61, 0x6e, 0x2e, 0x57, 0x69, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x4f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x07, 0x77, 0x69, 0x74, 0x68, 0x4b, 0x65, 0x79,
	0x12, 0x66, 0x0a, 0x0e, 0x6c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61,
	0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6c, 0x61, 0x6e,
	0x2e, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x4f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x0d, 0x6c, 0x6f, 0x6f, 0x6b, 0x75,
	0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x69, 0x0a, 0x0f, 0x6c, 0x6f, 0x6f, 0x6b,
	0x75, 0x70, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x3e, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6c, 0x61, 0x6e, 0x2e, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x48, 0x00, 0x52, 0x0e, 0x6c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0x54, 0x0a, 0x08, 0x73, 0x68, 0x69, 0x66, 0x74, 0x5f, 0x74, 0x6f, 0x18,
	0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e,
	0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e,
	0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6c, 0x61, 0x6e, 0x2e, 0x53, 0x68,
	0x69, 0x66, 0x74, 0x54, 0x6f, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00,
	0x52, 0x07, 0x73, 0x68, 0x69, 0x66, 0x74, 0x54, 0x6f, 0x12, 0x5d, 0x0a, 0x0b, 0x73, 0x68, 0x69,
	0x66, 0x74, 0x5f, 0x75, 0x6e, 0x74, 0x69, 0x6c, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a,
	0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61,
	0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x50, 0x6c, 0x61, 0x6e, 0x2e, 0x53, 0x68, 0x69, 0x66, 0x74, 0x55, 0x6e, 0x74, 0x69,
	0x6c, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x0a, 0x73, 0x68,
	0x69, 0x66, 0x74, 0x55, 0x6e, 0x74, 0x69, 0x6c, 0x1a, 0xc5, 0x01, 0x0a, 0x0d, 0x53, 0x63, 0x61,
	0x6e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x38, 0x0a, 0x08, 0x74, 0x61,
	0x62, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x6b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x55, 0x75, 0x69, 0x64, 0x52, 0x07, 0x74, 0x61, 0x62,
	0x6c, 0x65, 0x49, 0x64, 0x12, 0x37, 0x0a, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x53,
	0x63, 0x68, 0x65, 0x6d, 0x61, 0x52, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x41, 0x0a,
	0x0a, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x70, 0x6c, 0x61, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x22, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x53, 0x6c, 0x69, 0x63,
	0x65, 0x50, 0x6c, 0x61, 0x6e, 0x52, 0x09, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x6c, 0x61, 0x6e,
	0x1a, 0x3a, 0x0a, 0x0e, 0x4d, 0x65, 0x72, 0x67, 0x65, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x6c, 0x65, 0x66, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x04, 0x6c, 0x65, 0x66, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x69, 0x67, 0x68, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x72, 0x69, 0x67, 0x68, 0x74, 0x1a, 0x71, 0x0a, 0x0f,
	0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12,
	0x14, 0x0a, 0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05,
	0x69, 0x6e, 0x70, 0x75, 0x74, 0x12, 0x48, 0x0a, 0x09, 0x63, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61,
	0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x70, 0x75,
	0x74, 0x52, 0x65, 0x66, 0x52, 0x09, 0x63, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x1a,
	0x89, 0x01, 0x0a, 0x10, 0x57, 0x69, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x4f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x12, 0x43, 0x0a, 0x07, 0x6e, 0x65,
	0x77, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6b, 0x61,
	0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49,
	0x6e, 0x70, 0x75, 0x74, 0x52, 0x65, 0x66, 0x52, 0x06, 0x6e, 0x65, 0x77, 0x4b, 0x65, 0x79, 0x12,
	0x1a, 0x0a, 0x08, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x69, 0x6e, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x08, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x69, 0x6e, 0x67, 0x1a, 0xd4, 0x02, 0x0a, 0x0d,
	0x54, 0x69, 0x63, 0x6b, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x5d, 0x0a,
	0x08, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x41, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64,
	0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x50, 0x6c, 0x61, 0x6e, 0x2e, 0x54, 0x69, 0x63, 0x6b, 0x4f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x54, 0x69, 0x63, 0x6b, 0x42, 0x65, 0x68, 0x61, 0x76, 0x69,
	0x6f, 0x72, 0x52, 0x08, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x12, 0x14, 0x0a, 0x05,
	0x69, 0x6e, 0x70, 0x75, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x69, 0x6e, 0x70,
	0x75, 0x74, 0x22, 0xcd, 0x01, 0x0a, 0x0c, 0x54, 0x69, 0x63, 0x6b, 0x42, 0x65, 0x68, 0x61, 0x76,
	0x69, 0x6f, 0x72, 0x12, 0x1d, 0x0a, 0x19, 0x54, 0x49, 0x43, 0x4b, 0x5f, 0x42, 0x45, 0x48, 0x41,
	0x56, 0x49, 0x4f, 0x52, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44,
	0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16, 0x54, 0x49, 0x43, 0x4b, 0x5f, 0x42, 0x45, 0x48, 0x41, 0x56,
	0x49, 0x4f, 0x52, 0x5f, 0x46, 0x49, 0x4e, 0x49, 0x53, 0x48, 0x45, 0x44, 0x10, 0x01, 0x12, 0x18,
	0x0a, 0x14, 0x54, 0x49, 0x43, 0x4b, 0x5f, 0x42, 0x45, 0x48, 0x41, 0x56, 0x49, 0x4f, 0x52, 0x5f,
	0x48, 0x4f, 0x55, 0x52, 0x4c, 0x59, 0x10, 0x02, 0x12, 0x17, 0x0a, 0x13, 0x54, 0x49, 0x43, 0x4b,
	0x5f, 0x42, 0x45, 0x48, 0x41, 0x56, 0x49, 0x4f, 0x52, 0x5f, 0x44, 0x41, 0x49, 0x4c, 0x59, 0x10,
	0x03, 0x12, 0x19, 0x0a, 0x15, 0x54, 0x49, 0x43, 0x4b, 0x5f, 0x42, 0x45, 0x48, 0x41, 0x56, 0x49,
	0x4f, 0x52, 0x5f, 0x4d, 0x4f, 0x4e, 0x54, 0x48, 0x4c, 0x59, 0x10, 0x04, 0x12, 0x18, 0x0a, 0x14,
	0x54, 0x49, 0x43, 0x4b, 0x5f, 0x42, 0x45, 0x48, 0x41, 0x56, 0x49, 0x4f, 0x52, 0x5f, 0x59, 0x45,
	0x41, 0x52, 0x4c, 0x59, 0x10, 0x05, 0x12, 0x1a, 0x0a, 0x16, 0x54, 0x49, 0x43, 0x4b, 0x5f, 0x42,
	0x45, 0x48, 0x41, 0x56, 0x49, 0x4f, 0x52, 0x5f, 0x4d, 0x49, 0x4e, 0x55, 0x54, 0x45, 0x4c, 0x59,
	0x10, 0x06, 0x1a, 0x9b, 0x01, 0x0a, 0x16, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2b, 0x0a,
	0x11, 0x70, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x5f, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x10, 0x70, 0x72, 0x69, 0x6d, 0x61, 0x72,
	0x79, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x54, 0x0a, 0x10, 0x66, 0x6f,
	0x72, 0x65, 0x69, 0x67, 0x6e, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x52, 0x65, 0x66,
	0x52, 0x0e, 0x66, 0x6f, 0x72, 0x65, 0x69, 0x67, 0x6e, 0x4b, 0x65, 0x79, 0x48, 0x61, 0x73, 0x68,
	0x1a, 0xa2, 0x01, 0x0a, 0x17, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2b, 0x0a, 0x11,
	0x66, 0x6f, 0x72, 0x65, 0x69, 0x67, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x10, 0x66, 0x6f, 0x72, 0x65, 0x69, 0x67, 0x6e,
	0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x5a, 0x0a, 0x13, 0x72, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x68, 0x61, 0x73, 0x68,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61,
	0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61,
	0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x52,
	0x65, 0x66, 0x52, 0x11, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x4b, 0x65,
	0x79, 0x48, 0x61, 0x73, 0x68, 0x1a, 0xb2, 0x01, 0x0a, 0x10, 0x53, 0x68, 0x69, 0x66, 0x74, 0x54,
	0x6f, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6e,
	0x70, 0x75, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x69, 0x6e, 0x70, 0x75, 0x74,
	0x12, 0x48, 0x0a, 0x08, 0x63, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73,
	0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x52, 0x65, 0x66, 0x48, 0x00,
	0x52, 0x08, 0x63, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x64, 0x12, 0x36, 0x0a, 0x07, 0x6c, 0x69,
	0x74, 0x65, 0x72, 0x61, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69,
	0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x48, 0x00, 0x52, 0x07, 0x6c, 0x69, 0x74, 0x65, 0x72,
	0x61, 0x6c, 0x42, 0x06, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x1a, 0x75, 0x0a, 0x13, 0x53, 0x68,
	0x69, 0x66, 0x74, 0x55, 0x6e, 0x74, 0x69, 0x6c, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x12, 0x48, 0x0a, 0x09, 0x63, 0x6f, 0x6e, 0x64, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6b, 0x61, 0x73,
	0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e,
	0x70, 0x75, 0x74, 0x52, 0x65, 0x66, 0x52, 0x09, 0x63, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x42, 0x0a, 0x0a, 0x08, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x22, 0x86, 0x03,
	0x0a, 0x0e, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x6c, 0x61, 0x6e,
	0x12, 0x1c, 0x0a, 0x09, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0d, 0x52, 0x09, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x42,
	0x0a, 0x0b, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61,
	0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x44, 0x61,
	0x74, 0x61, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0a, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x12, 0x22, 0x0a, 0x0b, 0x69, 0x6e,
	0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x48,
	0x00, 0x52, 0x0b, 0x69, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x42,
	0x0a, 0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e,
	0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x52, 0x65, 0x66, 0x48, 0x00, 0x52, 0x05, 0x69, 0x6e, 0x70,
	0x75, 0x74, 0x12, 0x3c, 0x0a, 0x07, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61,
	0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4c, 0x69,
	0x74, 0x65, 0x72, 0x61, 0x6c, 0x48, 0x00, 0x52, 0x07, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c,
	0x12, 0x48, 0x0a, 0x0a, 0x6c, 0x61, 0x74, 0x65, 0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x27, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4c,
	0x61, 0x74, 0x65, 0x42, 0x6f, 0x75, 0x6e, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x48, 0x00, 0x52,
	0x09, 0x6c, 0x61, 0x74, 0x65, 0x42, 0x6f, 0x75, 0x6e, 0x64, 0x42, 0x0a, 0x0a, 0x08, 0x6f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x22, 0xb5, 0x0a, 0x0a, 0x07, 0x4c, 0x69, 0x74, 0x65, 0x72,
	0x61, 0x6c, 0x12, 0x14, 0x0a, 0x04, 0x62, 0x6f, 0x6f, 0x6c, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08,
	0x48, 0x00, 0x52, 0x04, 0x62, 0x6f, 0x6f, 0x6c, 0x12, 0x14, 0x0a, 0x04, 0x69, 0x6e, 0x74, 0x38,
	0x18, 0x09, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x04, 0x69, 0x6e, 0x74, 0x38, 0x12, 0x16,
	0x0a, 0x05, 0x69, 0x6e, 0x74, 0x31, 0x36, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52,
	0x05, 0x69, 0x6e, 0x74, 0x31, 0x36, 0x12, 0x16, 0x0a, 0x05, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x18,
	0x0b, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x05, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x12, 0x16,
	0x0a, 0x05, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x03, 0x48, 0x00, 0x52,
	0x05, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x12, 0x16, 0x0a, 0x05, 0x75, 0x69, 0x6e, 0x74, 0x38, 0x18,
	0x0d, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x05, 0x75, 0x69, 0x6e, 0x74, 0x38, 0x12, 0x18,
	0x0a, 0x06, 0x75, 0x69, 0x6e, 0x74, 0x31, 0x36, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00,
	0x52, 0x06, 0x75, 0x69, 0x6e, 0x74, 0x31, 0x36, 0x12, 0x18, 0x0a, 0x06, 0x75, 0x69, 0x6e, 0x74,
	0x33, 0x32, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x06, 0x75, 0x69, 0x6e, 0x74,
	0x33, 0x32, 0x12, 0x18, 0x0a, 0x06, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x18, 0x10, 0x20, 0x01,
	0x28, 0x04, 0x48, 0x00, 0x52, 0x06, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x12, 0x1a, 0x0a, 0x07,
	0x66, 0x6c, 0x6f, 0x61, 0x74, 0x33, 0x32, 0x18, 0x11, 0x20, 0x01, 0x28, 0x02, 0x48, 0x00, 0x52,
	0x07, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x33, 0x32, 0x12, 0x1a, 0x0a, 0x07, 0x66, 0x6c, 0x6f, 0x61,
	0x74, 0x36, 0x34, 0x18, 0x12, 0x20, 0x01, 0x28, 0x01, 0x48, 0x00, 0x52, 0x07, 0x66, 0x6c, 0x6f,
	0x61, 0x74, 0x36, 0x34, 0x12, 0x4f, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x18, 0x13, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64,
	0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68,
	0x61, 0x2e, 0x4c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x48, 0x00, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x18, 0x0a, 0x06, 0x64, 0x61, 0x74, 0x65, 0x33, 0x32, 0x18,
	0x14, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x06, 0x64, 0x61, 0x74, 0x65, 0x33, 0x32, 0x12,
	0x18, 0x0a, 0x06, 0x64, 0x61, 0x74, 0x65, 0x36, 0x34, 0x18, 0x15, 0x20, 0x01, 0x28, 0x03, 0x48,
	0x00, 0x52, 0x06, 0x64, 0x61, 0x74, 0x65, 0x36, 0x34, 0x12, 0x46, 0x0a, 0x06, 0x74, 0x69, 0x6d,
	0x65, 0x33, 0x32, 0x18, 0x16, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x2e, 0x4c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x2e, 0x54, 0x69, 0x6d, 0x65,
	0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x48, 0x00, 0x52, 0x06, 0x74, 0x69, 0x6d, 0x65, 0x33,
	0x32, 0x12, 0x46, 0x0a, 0x06, 0x74, 0x69, 0x6d, 0x65, 0x36, 0x34, 0x18, 0x17, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2c, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4c, 0x69, 0x74, 0x65,
	0x72, 0x61, 0x6c, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x48,
	0x00, 0x52, 0x06, 0x74, 0x69, 0x6d, 0x65, 0x36, 0x34, 0x12, 0x4c, 0x0a, 0x08, 0x64, 0x75, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x18, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6b, 0x61,
	0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x2e, 0x44, 0x75,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x48, 0x00, 0x52, 0x08, 0x64,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x63, 0x0a, 0x11, 0x69, 0x6e, 0x74, 0x65, 0x72,
	0x76, 0x61, 0x6c, 0x5f, 0x64, 0x61, 0x79, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x19, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x35, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73,
	0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4c, 0x69, 0x74,
	0x65, 0x72, 0x61, 0x6c, 0x2e, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x44, 0x61, 0x79,
	0x54, 0x69, 0x6d, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x48, 0x00, 0x52, 0x0f, 0x69, 0x6e, 0x74,
	0x65, 0x72, 0x76, 0x61, 0x6c, 0x44, 0x61, 0x79, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x29, 0x0a, 0x0f,
	0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x5f, 0x6d, 0x6f, 0x6e, 0x74, 0x68, 0x73, 0x18,
	0x1a, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x0e, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61,
	0x6c, 0x4d, 0x6f, 0x6e, 0x74, 0x68, 0x73, 0x12, 0x14, 0x0a, 0x04, 0x75, 0x74, 0x66, 0x38, 0x18,
	0x1b, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x04, 0x75, 0x74, 0x66, 0x38, 0x12, 0x46, 0x0a,
	0x06, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x18, 0x1c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e,
	0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x2e,
	0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x48, 0x00, 0x52, 0x06, 0x72,
	0x65, 0x63, 0x6f, 0x72, 0x64, 0x1a, 0x85, 0x01, 0x0a, 0x0e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x31, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x49, 0x6e, 0x74, 0x36, 0x34, 0x56,
	0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x75,
	0x6e, 0x69, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x6e, 0x69, 0x74, 0x12,
	0x2c, 0x0a, 0x02, 0x74, 0x7a, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x74,
	0x72, 0x69, 0x6e, 0x67, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x02, 0x74, 0x7a, 0x1a, 0x37, 0x0a,
	0x0b, 0x54, 0x69, 0x6d, 0x65, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x14, 0x0a, 0x05,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x6e, 0x69, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x04, 0x75, 0x6e, 0x69, 0x74, 0x1a, 0x37, 0x0a, 0x0b, 0x54, 0x69, 0x6d, 0x65, 0x36, 0x34,
	0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x75,
	0x6e, 0x69, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x6e, 0x69, 0x74, 0x1a,
	0x39, 0x0a, 0x0d, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x56, 0x61, 0x6c, 0x75, 0x65,
	0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x6e, 0x69, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x6e, 0x69, 0x74, 0x1a, 0x3e, 0x0a, 0x14, 0x49, 0x6e,
	0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x44, 0x61, 0x79, 0x54, 0x69, 0x6d, 0x65, 0x56, 0x61, 0x6c,
	0x75, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x65, 0x6e, 0x64, 0x1a, 0x47, 0x0a, 0x0b, 0x52, 0x65,
	0x63, 0x6f, 0x72, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x38, 0x0a, 0x06, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x2e, 0x4c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x52, 0x06, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x73, 0x42, 0x09, 0x0a, 0x07, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x22, 0x94,
	0x05, 0x0a, 0x11, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x70, 0x75,
	0x74, 0x52, 0x65, 0x66, 0x12, 0x2f, 0x0a, 0x13, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x69, 0x6e,
	0x67, 0x5f, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x12, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x69, 0x6e, 0x67, 0x4f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x55, 0x0a, 0x0a, 0x6b, 0x65, 0x79, 0x5f, 0x63, 0x6f, 0x6c,
	0x75, 0x6d, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x34, 0x2e, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x70,
	0x75, 0x74, 0x52, 0x65, 0x66, 0x2e, 0x4b, 0x65, 0x79, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x48,
	0x00, 0x52, 0x09, 0x6b, 0x65, 0x79, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x12, 0x31, 0x0a, 0x13,
	0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x72, 0x5f, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73,
	0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x12, 0x70, 0x72, 0x6f,
	0x64, 0x75, 0x63, 0x65, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12,
	0x39, 0x0a, 0x0b, 0x73, 0x63, 0x61, 0x6e, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x48, 0x00, 0x52, 0x0a,
	0x73, 0x63, 0x61, 0x6e, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x2c, 0x0a, 0x04, 0x74, 0x69,
	0x63, 0x6b, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79,
	0x48, 0x00, 0x52, 0x04, 0x74, 0x69, 0x63, 0x6b, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x6e, 0x70, 0x75,
	0x74, 0x5f, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b,
	0x69, 0x6e, 0x70, 0x75, 0x74, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x12, 0x5e, 0x0a, 0x0d, 0x69,
	0x6e, 0x74, 0x65, 0x72, 0x70, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x38, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73,
	0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x2e, 0x4f, 0x70, 0x65,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x52, 0x65, 0x66, 0x2e, 0x49,
	0x6e, 0x74, 0x65, 0x72, 0x70, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0d, 0x69, 0x6e,
	0x74, 0x65, 0x72, 0x70, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x6d, 0x0a, 0x09, 0x4b,
	0x65, 0x79, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x12, 0x1a, 0x0a, 0x16, 0x4b, 0x45, 0x59, 0x5f,
	0x43, 0x4f, 0x4c, 0x55, 0x4d, 0x4e, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49,
	0x45, 0x44, 0x10, 0x00, 0x12, 0x13, 0x0a, 0x0f, 0x4b, 0x45, 0x59, 0x5f, 0x43, 0x4f, 0x4c, 0x55,
	0x4d, 0x4e, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x10, 0x01, 0x12, 0x16, 0x0a, 0x12, 0x4b, 0x45, 0x59,
	0x5f, 0x43, 0x4f, 0x4c, 0x55, 0x4d, 0x4e, 0x5f, 0x53, 0x55, 0x42, 0x53, 0x4f, 0x52, 0x54, 0x10,
	0x02, 0x12, 0x17, 0x0a, 0x13, 0x4b, 0x45, 0x59, 0x5f, 0x43, 0x4f, 0x4c, 0x55, 0x4d, 0x4e, 0x5f,
	0x4b, 0x45, 0x59, 0x5f, 0x48, 0x41, 0x53, 0x48, 0x10, 0x03, 0x22, 0x5f, 0x0a, 0x0d, 0x49, 0x6e,
	0x74, 0x65, 0x72, 0x70, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x19, 0x49,
	0x4e, 0x54, 0x45, 0x52, 0x50, 0x4f, 0x4c, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x55, 0x4e, 0x53,
	0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x16, 0x0a, 0x12, 0x49, 0x4e,
	0x54, 0x45, 0x52, 0x50, 0x4f, 0x4c, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x4e, 0x55, 0x4c, 0x4c,
	0x10, 0x01, 0x12, 0x17, 0x0a, 0x13, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x50, 0x4f, 0x4c, 0x41, 0x54,
	0x49, 0x4f, 0x4e, 0x5f, 0x41, 0x53, 0x5f, 0x4f, 0x46, 0x10, 0x02, 0x42, 0x08, 0x0a, 0x06, 0x63,
	0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x2a, 0x7f, 0x0a, 0x0e, 0x4c, 0x61, 0x74, 0x65, 0x42, 0x6f, 0x75,
	0x6e, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x20, 0x0a, 0x1c, 0x4c, 0x41, 0x54, 0x45, 0x5f,
	0x42, 0x4f, 0x55, 0x4e, 0x44, 0x5f, 0x56, 0x41, 0x4c, 0x55, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50,
	0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x27, 0x0a, 0x23, 0x4c, 0x41, 0x54,
	0x45, 0x5f, 0x42, 0x4f, 0x55, 0x4e, 0x44, 0x5f, 0x56, 0x41, 0x4c, 0x55, 0x45, 0x5f, 0x43, 0x48,
	0x41, 0x4e, 0x47, 0x45, 0x44, 0x5f, 0x53, 0x49, 0x4e, 0x43, 0x45, 0x5f, 0x54, 0x49, 0x4d, 0x45,
	0x10, 0x01, 0x12, 0x22, 0x0a, 0x1e, 0x4c, 0x41, 0x54, 0x45, 0x5f, 0x42, 0x4f, 0x55, 0x4e, 0x44,
	0x5f, 0x56, 0x41, 0x4c, 0x55, 0x45, 0x5f, 0x46, 0x49, 0x4e, 0x41, 0x4c, 0x5f, 0x41, 0x54, 0x5f,
	0x54, 0x49, 0x4d, 0x45, 0x10, 0x02, 0x42, 0xf5, 0x01, 0x0a, 0x1b, 0x63, 0x6f, 0x6d, 0x2e, 0x6b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x42, 0x09, 0x50, 0x6c, 0x61, 0x6e, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x50, 0x01, 0x5a, 0x4d, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2f, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2d,
	0x61, 0x69, 0x2f, 0x77, 0x72, 0x65, 0x6e, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x6b, 0x61, 0x73, 0x6b,
	0x61, 0x64, 0x61, 0x2f, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2f, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x3b, 0x6b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0xa2, 0x02, 0x03, 0x4b, 0x4b, 0x58, 0xaa, 0x02, 0x17, 0x4b, 0x61, 0x73, 0x6b, 0x61,
	0x64, 0x61, 0x2e, 0x4b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x2e, 0x56, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0xca, 0x02, 0x17, 0x4b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x5c, 0x4b, 0x61, 0x73,
	0x6b, 0x61, 0x64, 0x61, 0x5c, 0x56, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0xe2, 0x02, 0x23, 0x4b,
	0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x5c, 0x4b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x5c, 0x56,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61,
	0x74, 0x61, 0xea, 0x02, 0x19, 0x4b, 0x61, 0x73, 0x6b, 0x61, 0x64, 0x61, 0x3a, 0x3a, 0x4b, 0x61,
	0x73, 0x6b, 0x61, 0x64, 0x61, 0x3a, 0x3a, 0x56, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x62, 0x06,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_kaskada_kaskada_v1alpha_plan_proto_rawDescOnce sync.Once
	file_kaskada_kaskada_v1alpha_plan_proto_rawDescData = file_kaskada_kaskada_v1alpha_plan_proto_rawDesc
)

func file_kaskada_kaskada_v1alpha_plan_proto_rawDescGZIP() []byte {
	file_kaskada_kaskada_v1alpha_plan_proto_rawDescOnce.Do(func() {
		file_kaskada_kaskada_v1alpha_plan_proto_rawDescData = protoimpl.X.CompressGZIP(file_kaskada_kaskada_v1alpha_plan_proto_rawDescData)
	})
	return file_kaskada_kaskada_v1alpha_plan_proto_rawDescData
}

var file_kaskada_kaskada_v1alpha_plan_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_kaskada_kaskada_v1alpha_plan_proto_msgTypes = make([]protoimpl.MessageInfo, 20)
var file_kaskada_kaskada_v1alpha_plan_proto_goTypes = []interface{}{
	(LateBoundValue)(0),                           // 0: kaskada.kaskada.v1alpha.LateBoundValue
	(OperationPlan_TickOperation_TickBehavior)(0), // 1: kaskada.kaskada.v1alpha.OperationPlan.TickOperation.TickBehavior
	(OperationInputRef_KeyColumn)(0),              // 2: kaskada.kaskada.v1alpha.OperationInputRef.KeyColumn
	(OperationInputRef_Interpolation)(0),          // 3: kaskada.kaskada.v1alpha.OperationInputRef.Interpolation
	(*ComputePlan)(nil),                           // 4: kaskada.kaskada.v1alpha.ComputePlan
	(*OperationPlan)(nil),                         // 5: kaskada.kaskada.v1alpha.OperationPlan
	(*ExpressionPlan)(nil),                        // 6: kaskada.kaskada.v1alpha.ExpressionPlan
	(*Literal)(nil),                               // 7: kaskada.kaskada.v1alpha.Literal
	(*OperationInputRef)(nil),                     // 8: kaskada.kaskada.v1alpha.OperationInputRef
	(*OperationPlan_ScanOperation)(nil),           // 9: kaskada.kaskada.v1alpha.OperationPlan.ScanOperation
	(*OperationPlan_MergeOperation)(nil),          // 10: kaskada.kaskada.v1alpha.OperationPlan.MergeOperation
	(*OperationPlan_SelectOperation)(nil),         // 11: kaskada.kaskada.v1alpha.OperationPlan.SelectOperation
	(*OperationPlan_WithKeyOperation)(nil),        // 12: kaskada.kaskada.v1alpha.OperationPlan.WithKeyOperation
	(*OperationPlan_TickOperation)(nil),           // 13: kaskada.kaskada.v1alpha.OperationPlan.TickOperation
	(*OperationPlan_LookupRequestOperation)(nil),  // 14: kaskada.kaskada.v1alpha.OperationPlan.LookupRequestOperation
	(*OperationPlan_LookupResponseOperation)(nil), // 15: kaskada.kaskada.v1alpha.OperationPlan.LookupResponseOperation
	(*OperationPlan_ShiftToOperation)(nil),        // 16: kaskada.kaskada.v1alpha.OperationPlan.ShiftToOperation
	(*OperationPlan_ShiftUntilOperation)(nil),     // 17: kaskada.kaskada.v1alpha.OperationPlan.ShiftUntilOperation
	(*Literal_TimestampValue)(nil),                // 18: kaskada.kaskada.v1alpha.Literal.TimestampValue
	(*Literal_Time32Value)(nil),                   // 19: kaskada.kaskada.v1alpha.Literal.Time32Value
	(*Literal_Time64Value)(nil),                   // 20: kaskada.kaskada.v1alpha.Literal.Time64Value
	(*Literal_DurationValue)(nil),                 // 21: kaskada.kaskada.v1alpha.Literal.DurationValue
	(*Literal_IntervalDayTimeValue)(nil),          // 22: kaskada.kaskada.v1alpha.Literal.IntervalDayTimeValue
	(*Literal_RecordValue)(nil),                   // 23: kaskada.kaskada.v1alpha.Literal.RecordValue
	(PerEntityBehavior)(0),                        // 24: kaskada.kaskada.v1alpha.PerEntityBehavior
	(*DataType)(nil),                              // 25: kaskada.kaskada.v1alpha.DataType
	(*emptypb.Empty)(nil),                         // 26: google.protobuf.Empty
	(*Uuid)(nil),                                  // 27: kaskada.kaskada.v1alpha.Uuid
	(*Schema)(nil),                                // 28: kaskada.kaskada.v1alpha.Schema
	(*SlicePlan)(nil),                             // 29: kaskada.kaskada.v1alpha.SlicePlan
	(*timestamppb.Timestamp)(nil),                 // 30: google.protobuf.Timestamp
	(*wrapperspb.Int64Value)(nil),                 // 31: google.protobuf.Int64Value
	(*wrapperspb.StringValue)(nil),                // 32: google.protobuf.StringValue
}
var file_kaskada_kaskada_v1alpha_plan_proto_depIdxs = []int32{
	24, // 0: kaskada.kaskada.v1alpha.ComputePlan.per_entity_behavior:type_name -> kaskada.kaskada.v1alpha.PerEntityBehavior
	5,  // 1: kaskada.kaskada.v1alpha.ComputePlan.operations:type_name -> kaskada.kaskada.v1alpha.OperationPlan
	25, // 2: kaskada.kaskada.v1alpha.ComputePlan.primary_grouping_key_type:type_name -> kaskada.kaskada.v1alpha.DataType
	6,  // 3: kaskada.kaskada.v1alpha.OperationPlan.expressions:type_name -> kaskada.kaskada.v1alpha.ExpressionPlan
	9,  // 4: kaskada.kaskada.v1alpha.OperationPlan.scan:type_name -> kaskada.kaskada.v1alpha.OperationPlan.ScanOperation
	10, // 5: kaskada.kaskada.v1alpha.OperationPlan.merge:type_name -> kaskada.kaskada.v1alpha.OperationPlan.MergeOperation
	11, // 6: kaskada.kaskada.v1alpha.OperationPlan.select:type_name -> kaskada.kaskada.v1alpha.OperationPlan.SelectOperation
	13, // 7: kaskada.kaskada.v1alpha.OperationPlan.tick:type_name -> kaskada.kaskada.v1alpha.OperationPlan.TickOperation
	12, // 8: kaskada.kaskada.v1alpha.OperationPlan.with_key:type_name -> kaskada.kaskada.v1alpha.OperationPlan.WithKeyOperation
	14, // 9: kaskada.kaskada.v1alpha.OperationPlan.lookup_request:type_name -> kaskada.kaskada.v1alpha.OperationPlan.LookupRequestOperation
	15, // 10: kaskada.kaskada.v1alpha.OperationPlan.lookup_response:type_name -> kaskada.kaskada.v1alpha.OperationPlan.LookupResponseOperation
	16, // 11: kaskada.kaskada.v1alpha.OperationPlan.shift_to:type_name -> kaskada.kaskada.v1alpha.OperationPlan.ShiftToOperation
	17, // 12: kaskada.kaskada.v1alpha.OperationPlan.shift_until:type_name -> kaskada.kaskada.v1alpha.OperationPlan.ShiftUntilOperation
	25, // 13: kaskada.kaskada.v1alpha.ExpressionPlan.result_type:type_name -> kaskada.kaskada.v1alpha.DataType
	8,  // 14: kaskada.kaskada.v1alpha.ExpressionPlan.input:type_name -> kaskada.kaskada.v1alpha.OperationInputRef
	7,  // 15: kaskada.kaskada.v1alpha.ExpressionPlan.literal:type_name -> kaskada.kaskada.v1alpha.Literal
	0,  // 16: kaskada.kaskada.v1alpha.ExpressionPlan.late_bound:type_name -> kaskada.kaskada.v1alpha.LateBoundValue
	18, // 17: kaskada.kaskada.v1alpha.Literal.timestamp:type_name -> kaskada.kaskada.v1alpha.Literal.TimestampValue
	19, // 18: kaskada.kaskada.v1alpha.Literal.time32:type_name -> kaskada.kaskada.v1alpha.Literal.Time32Value
	20, // 19: kaskada.kaskada.v1alpha.Literal.time64:type_name -> kaskada.kaskada.v1alpha.Literal.Time64Value
	21, // 20: kaskada.kaskada.v1alpha.Literal.duration:type_name -> kaskada.kaskada.v1alpha.Literal.DurationValue
	22, // 21: kaskada.kaskada.v1alpha.Literal.interval_day_time:type_name -> kaskada.kaskada.v1alpha.Literal.IntervalDayTimeValue
	23, // 22: kaskada.kaskada.v1alpha.Literal.record:type_name -> kaskada.kaskada.v1alpha.Literal.RecordValue
	2,  // 23: kaskada.kaskada.v1alpha.OperationInputRef.key_column:type_name -> kaskada.kaskada.v1alpha.OperationInputRef.KeyColumn
	26, // 24: kaskada.kaskada.v1alpha.OperationInputRef.scan_record:type_name -> google.protobuf.Empty
	26, // 25: kaskada.kaskada.v1alpha.OperationInputRef.tick:type_name -> google.protobuf.Empty
	3,  // 26: kaskada.kaskada.v1alpha.OperationInputRef.interpolation:type_name -> kaskada.kaskada.v1alpha.OperationInputRef.Interpolation
	27, // 27: kaskada.kaskada.v1alpha.OperationPlan.ScanOperation.table_id:type_name -> kaskada.kaskada.v1alpha.Uuid
	28, // 28: kaskada.kaskada.v1alpha.OperationPlan.ScanOperation.schema:type_name -> kaskada.kaskada.v1alpha.Schema
	29, // 29: kaskada.kaskada.v1alpha.OperationPlan.ScanOperation.slice_plan:type_name -> kaskada.kaskada.v1alpha.SlicePlan
	8,  // 30: kaskada.kaskada.v1alpha.OperationPlan.SelectOperation.condition:type_name -> kaskada.kaskada.v1alpha.OperationInputRef
	8,  // 31: kaskada.kaskada.v1alpha.OperationPlan.WithKeyOperation.new_key:type_name -> kaskada.kaskada.v1alpha.OperationInputRef
	1,  // 32: kaskada.kaskada.v1alpha.OperationPlan.TickOperation.behavior:type_name -> kaskada.kaskada.v1alpha.OperationPlan.TickOperation.TickBehavior
	8,  // 33: kaskada.kaskada.v1alpha.OperationPlan.LookupRequestOperation.foreign_key_hash:type_name -> kaskada.kaskada.v1alpha.OperationInputRef
	8,  // 34: kaskada.kaskada.v1alpha.OperationPlan.LookupResponseOperation.requesting_key_hash:type_name -> kaskada.kaskada.v1alpha.OperationInputRef
	8,  // 35: kaskada.kaskada.v1alpha.OperationPlan.ShiftToOperation.computed:type_name -> kaskada.kaskada.v1alpha.OperationInputRef
	30, // 36: kaskada.kaskada.v1alpha.OperationPlan.ShiftToOperation.literal:type_name -> google.protobuf.Timestamp
	8,  // 37: kaskada.kaskada.v1alpha.OperationPlan.ShiftUntilOperation.condition:type_name -> kaskada.kaskada.v1alpha.OperationInputRef
	31, // 38: kaskada.kaskada.v1alpha.Literal.TimestampValue.value:type_name -> google.protobuf.Int64Value
	32, // 39: kaskada.kaskada.v1alpha.Literal.TimestampValue.tz:type_name -> google.protobuf.StringValue
	7,  // 40: kaskada.kaskada.v1alpha.Literal.RecordValue.values:type_name -> kaskada.kaskada.v1alpha.Literal
	41, // [41:41] is the sub-list for method output_type
	41, // [41:41] is the sub-list for method input_type
	41, // [41:41] is the sub-list for extension type_name
	41, // [41:41] is the sub-list for extension extendee
	0,  // [0:41] is the sub-list for field type_name
}

func init() { file_kaskada_kaskada_v1alpha_plan_proto_init() }
func file_kaskada_kaskada_v1alpha_plan_proto_init() {
	if File_kaskada_kaskada_v1alpha_plan_proto != nil {
		return
	}
	file_kaskada_kaskada_v1alpha_common_proto_init()
	file_kaskada_kaskada_v1alpha_schema_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ComputePlan); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OperationPlan); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExpressionPlan); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Literal); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OperationInputRef); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OperationPlan_ScanOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OperationPlan_MergeOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OperationPlan_SelectOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OperationPlan_WithKeyOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OperationPlan_TickOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OperationPlan_LookupRequestOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OperationPlan_LookupResponseOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OperationPlan_ShiftToOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OperationPlan_ShiftUntilOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Literal_TimestampValue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Literal_Time32Value); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Literal_Time64Value); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Literal_DurationValue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Literal_IntervalDayTimeValue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Literal_RecordValue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[1].OneofWrappers = []interface{}{
		(*OperationPlan_Scan)(nil),
		(*OperationPlan_Merge)(nil),
		(*OperationPlan_Select)(nil),
		(*OperationPlan_Tick)(nil),
		(*OperationPlan_WithKey)(nil),
		(*OperationPlan_LookupRequest)(nil),
		(*OperationPlan_LookupResponse)(nil),
		(*OperationPlan_ShiftTo)(nil),
		(*OperationPlan_ShiftUntil)(nil),
	}
	file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[2].OneofWrappers = []interface{}{
		(*ExpressionPlan_Instruction)(nil),
		(*ExpressionPlan_Input)(nil),
		(*ExpressionPlan_Literal)(nil),
		(*ExpressionPlan_LateBound)(nil),
	}
	file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[3].OneofWrappers = []interface{}{
		(*Literal_Bool)(nil),
		(*Literal_Int8)(nil),
		(*Literal_Int16)(nil),
		(*Literal_Int32)(nil),
		(*Literal_Int64)(nil),
		(*Literal_Uint8)(nil),
		(*Literal_Uint16)(nil),
		(*Literal_Uint32)(nil),
		(*Literal_Uint64)(nil),
		(*Literal_Float32)(nil),
		(*Literal_Float64)(nil),
		(*Literal_Timestamp)(nil),
		(*Literal_Date32)(nil),
		(*Literal_Date64)(nil),
		(*Literal_Time32)(nil),
		(*Literal_Time64)(nil),
		(*Literal_Duration)(nil),
		(*Literal_IntervalDayTime)(nil),
		(*Literal_IntervalMonths)(nil),
		(*Literal_Utf8)(nil),
		(*Literal_Record)(nil),
	}
	file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*OperationInputRef_KeyColumn_)(nil),
		(*OperationInputRef_ProducerExpression)(nil),
		(*OperationInputRef_ScanRecord)(nil),
		(*OperationInputRef_Tick)(nil),
	}
	file_kaskada_kaskada_v1alpha_plan_proto_msgTypes[12].OneofWrappers = []interface{}{
		(*OperationPlan_ShiftToOperation_Computed)(nil),
		(*OperationPlan_ShiftToOperation_Literal)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_kaskada_kaskada_v1alpha_plan_proto_rawDesc,
			NumEnums:      4,
			NumMessages:   20,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_kaskada_kaskada_v1alpha_plan_proto_goTypes,
		DependencyIndexes: file_kaskada_kaskada_v1alpha_plan_proto_depIdxs,
		EnumInfos:         file_kaskada_kaskada_v1alpha_plan_proto_enumTypes,
		MessageInfos:      file_kaskada_kaskada_v1alpha_plan_proto_msgTypes,
	}.Build()
	File_kaskada_kaskada_v1alpha_plan_proto = out.File
	file_kaskada_kaskada_v1alpha_plan_proto_rawDesc = nil
	file_kaskada_kaskada_v1alpha_plan_proto_goTypes = nil
	file_kaskada_kaskada_v1alpha_plan_proto_depIdxs = nil
}
