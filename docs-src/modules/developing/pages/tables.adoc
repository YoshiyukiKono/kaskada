= Tables 

Kaskada stores data in _tables_. Tables consist of multiple rows, and
each row is a value of the same type.

== Managing tables with the CLI

The CLI manages Kaskada resources declaratively by managing spec files.
A spec file is a YAML file describing a set of Kaskada resources, for examples tables and views.

=== The format of tables in a spec file.

Tables are described in a spec file as a list of table objects under the `tables` key:

[source,yaml]
----
tables:
  - table_id: 14c4...ba56 <1>
    table_name: GamePlay <2>
    entity_key_column_name: entity_id <3>
    time_column_name: event_at <4>
    grouping_id: User <5>
    subsort_column_name: offset <5>

  - table_id: dd61...70e9
    table_name: Purchase
    entity_key_column_name: entity_id
    time_column_name: event_at
    grouping_id: User
----
<1> A unique identifier for the table. This value is assigned by the manager and is read-only.
<2> A name used to refer to the contents of the table in queries.
<3> The name of the entity key column within the table.
<4> The name of the time column within the table.
<5> An optional name of the subsort column within the table.


=== Exporting the current tables as a spec file.

You can export all the tables currently defined using the CLI.

[source,bash]
----
cli sync export --all
----

The export result is shown below

[source,yaml]
----
tables:
  - table_id: 14c4...ba56
    table_name: GamePlay
    entity_key_column_name: entity_id
    time_column_name: event_at
    grouping_id: User
    subsort_column_name: offset
views:
    # ...
----

Alternately, if you know a specific table you'd like to export you can specify it explicitly.

[source,bash]
----
cli sync export --table Purchase
----

=== Updating Kaskada to reflect the contents of a spec file

To change a table with the CLI, you first modify the table in a spec file, then "apply" the spec file with the CLI.
When a spec file is applied, the CLI inspects all of the server's resources and all of the resources
defined in your spec file, then takes whatever actions are necessary to reconcile the server's state.
Applying a spec can create new tables, change a tables's mutable fields, or delete tables.

[WARNING]
.Table updates are destructive
====
Tables are currently immutable. 
When the CLI updates a table, it does so by deleting the table and re-creating it.
When this happens, all data previously loaded into the table is lost.
====

Before applying a spec file, it's a good idea to see what changes will be made. 
You can see these changes by creating an apply plan.

[source,bash]
----
cli sync plan --file spec.yaml
----

Running this command will not make any changes to the server, but will print out the changes that will be made if you apply the given spec file.

You can apply a spec file using the CLI.

[source,bash]
----
cli sync apply --file spec.yaml
----

== Managing tables with Python

All methods on this page use the `table` module. Be sure to import it
before running any method:

[source,python]
----
from kaskada import table
----

=== Creating a Table

When creating a table, you must provide information about how each row
should be interpreted. You must describe:

* A field containing the time associated with each row. The time should
refer to when the event occurred.
* An initial xref:fenl:entities[entity] key associated with each row. The
entity should identify a _thing_ in the world related to each event.

Optionally:

* A subsort column associated with each row. This value is used to order
rows associated with the same time value. If no subsort column is
provided, Kaskada will generate one.

For more information about these fields, see:
xref:reference:expected-file-format[Expected File Format]

Here is an example of creating a table:

[source,python]
----
table.create_table(
  table_name = "Purchase",
  time_column_name = "purchase_time",
  entity_key_column_name = "customer_id",
  subsort_column_name = "subsort_id",
)
----

This creates a table named `Purchase`. Any data loaded into this table
must have a timestamp field named `purchase_time`, `customer_id`, and a
field called `subsort_id`.

[TIP]
.Idiomatic Kaskada 
====
We like to use CamelCase to name tables because it
helps distinguish data sources from transformed values and function
names.
====

=== List Tables

The list table method returns all tables defined for your user. An
optional search string can filter the response set.

Here is an example of listing tables:

[source,python]
----
table.list_tables(search = "chase")
----

=== Get Table

You can get a table using its name:

[source,python]
----
table.get_table("Purchase")
----

=== Updating a Table

Tables are currently immutable. Updating a table requires deleting it
and then re-creating it with a new expression.

=== Deleting a table

You can delete a table using its name:

[source,python]
----
table.delete_table("Purchase")
----

[WARNING]
====
Note that deleting a table also deletes any events uploaded to it.
====

A failed precondition error is returned if another view and/or
materialization references the table. To continue with the deletion of
the table, delete the dependent resources or supply the `force` flag to
delete the table forcefully. Forcefully deleting a table without
deleting the dependent resources may result in the dependent resources
functioning incorrectly.

[source,python]
----
table.delete_table("Purchase", force=True)
----