[WARNING]
.Setup Required
====
The following examples assume you've already completed
xref::hello-querying-data.adoc[Querying Data].
====

== Creating a View

Fenl expressions can be shared and re-used by creating a _view_. A view
is a named expression. In subsequent Fenl expressions, the view's name
is synonymous with the view's expression. Views are persisted in the
Kaskada platform and are accessible to any query.

To create a view, we'll start by describing the expression we'd like to
name. In this case, we're interested in some purchase statistics for
each user. This definition depends on business logic and might require
some iteration to get just right, so we'll use the IPython "fenlmagic"
extension to explore the results of our query.

[source,IPython]
----
%%fenl --var purchase_stats
{
    time: Purchase.purchase_time,
    entity: Purchase.customer_id,
    max_amount: Purchase.amount | max(),
    min_amount: Purchase.amount | min(),
}
----

Notice that we added `--var purchase_stats` to the beginning of the
magic block; this causes the extension to assign the query string to the
variable `purchase_stats` when the block is run. To verify this:

[source,IPython]
----
purchase_stats
----

[NOTE]
.Usage
====
The fenlmagic extension is designed to make it easy to interactively
explore your dataset. The python client exposes the full functionality
of the Kaskada API and is better suited to tasks such as managing Views,
Tables, and making multiple queries with different query variables.
====

We can use this variable to create a view using the Python client
without re-typing the expression:

[source,python]
----
from kaskada import view

view.create_view(
    view_name = "PurchaseStats",
    expression = purchase_stats.query,
)
----


[TIP]
.Idiomatic Kaskada
====
We like to use CamelCase for view names. This is the same naming
convention as we use for tables, and helps to communicate that we're
referring to a persistent resource in the Kaskada system, as opposed to
a temporary local value created as part of a query.
====

We've now created a view named `PurchaseStats`. We can verify it was
created successfully by searching for views matching the name:

[source,python]
----
view.list_views()
----

[source,json]
----
views {
  view_id: "34a2d3***813bb1"
  view_name: "PurchaseStats"
  expression: "{
    time: Purchase.purchase_time,
    entity: Purchase.customer_id,
    max_amount: Purchase.amount | max(),
    min_amount: Purchase.amount | min(),
  }"
}
request_details {
  request_id: "fe6bed41fa29cea6ca85fe20bea6ef4d"
}
----

== Using a view

Now that we've created a view, let's look at how the view can be used.
We can use a view's name anywhere we could use the view's expression -
the only restriction placed on views is that they must be valid Fenl
expressions.

Here's an example of using a view to filter the values produced by an
expression:

[source,IPython]
----
%%fenl
{
  time: Purchase.purchase_time,
  entity: Purchase.customer_id,
  total_purchases: Purchase.amount | sum(),
} | when(PurchaseStats.max_amount > 100)
----

Views may reference other views, so we could give this expression a name
and create a view for it as well if we wanted to.

Views are useful any time you need to share or re-use expressions:

* Cleaning operations
* Common business logic
* Final feature vectors

For more help with views, see xref:reference:views.adoc[Reference - Working with Views]
