= Getting Started

== Reasoning about events with timelines

Kaskada is a unified event processing engine that provides stateful stream processing in a high-level query language designed specifically for reasoning about events in bulk and in real time.
Kaskada is built on the idea of a _timeline_ - the history of how a value changes over time for a specific entity or group.

[stream_viz,name=basic-sum]
.Aggregating events as a timeline
....
[
    {
        "label": "Purchase.amount",
        "kind": "discrete",
        "data": [
            [
                {"t": 2, "v": "5"},
                {"t": 4, "v": "2"},
                {"t": 13, "v": "13"},
                {"t": 18, "v": "4"}
            ]
        ]
    },
    {
        "label": "Purchase.amount | sum()",
        "kind": "continuous",
        "data": [
            [
                {"t": 2, "v": "5"},
                {"t": 4, "v": "7"},
                {"t": 13, "v": "20"},
                {"t": 18, "v": "24"}
            ]
        ]
    }
]
....

Timelines give you declarative queries and the ability to reason about temporal context, time travel, sequencing, timeseries, and more.
Transforming and combining timelines allow you to intuitively express computations over events.

****
⭢ Read more about timelines in xref:overview:what-is-kaskada.adoc[]
****

With Kaskada, it's timelines all the way down - every operation starts from timelines and produces timelines. 
When you make a query, the resulting timeline is converted to a table in one of two ways: as a value history or as a value snapshot. 

* *Value history* generates a row each time the timeline changes, and each row is associated with a different entity and point in time. 
* *Value snapshot* generates a row for each entity at the _same_ point in time; each row is associated with a different entity, but all rows are associated with the same time.

****
⭢ Read more about converting to tables in xref:developing:queries.adoc#configuring-how-queries-are-computed[Queries]
****

== Kaskada's basic architecture

Kaskada is implemented as a standalone service with two main components.

* The *engine* is a stateful compute engine for transforming event data.
* The *manager* is a stateful compute engine for transforming event data.

These components are distributed as dependency-free binaries.
Kaskada is managed using an API, and multiple clients exist to communicate with the API, including Python and a CLI binary.
Kaskada can be configured to run as a remote service or as a local process.

****
⭢ Read more about installing Kaskada in xref:ROOT:installing.adoc[]
****

Kaskada stores data in tables. Tables consist of multiple rows, and each row is a value of the same type.
Events must be loaded into a table before they can be queried.

****
⭢ Read more about loading data in xref:ROOT:loading-data.adoc[]
****

== Quick-starts

The next section of the docs shows how to quickly get started with Kaskada.
You'll see how to install Kaskada, create tables, load data, and make simple queries.
You can pick the development environment that's most familiar to you.

****
⭢ Try out Kaskada using Jupyter in xref:getting-started:hello-world-jupyter.adoc[]

⭢ Try out Kaskada using the CLI in xref:getting-started:hello-world-cli.adoc[]
****

[TIP]
.Installing different clients
====
The Python and CLI clients are independent and are installed separately.
For example, you don't need to install the Python client in order to use the CLI.
If you would like use both, you must install them independently.
====