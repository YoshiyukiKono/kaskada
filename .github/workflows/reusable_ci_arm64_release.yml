####
## Duplicates steps from release_engine.yml because
##
## - We need to run Go's cross compile inside a custom docker image
##   - GitHub's `if:` does not let us opt out of adding a container to a job
##      - Possible option is to create a custom action that uses the docker image
##        for the cross build only and share all other steps
##   - GitHub action to install Go does not work with the image used for cross compile
##     Reason is that the image sets everything up for ARM64 and it takes more work
##     to undo and redo the setup. Solution right now is to install go in the image ourselves
##
## - For Rust we are using the `cross` crate but
##     -  we are pulling in an updated docker image rather than the one the current
##        cross version pulls by default (v0.2.5 which runs a container under Ubuntu 16).
##
## Deviations are marked in the file.
####

on:
  workflow_call:
  workflow_dispatch:

permissions:
  # For deploying release artifacts.
  contents: write
  pull-requests: read
  # For pushing Docker images to ghcr.io.
  packages: write
  # For creating the release announcement.
  discussions: write

env:
  IMAGE: ghcr.io/${{ github.repository }}/go-cross-compile-to-arm64
  PRE_RELEASE_IMAGE: ghcr.io/${{ github.repository }}/engine-arm64

name: Build linux/aarch64

jobs:
  # build_cross_docker_image:
  #   runs-on: ubuntu-20.04
  #   outputs:
  #     image-name: ${{ env.IMAGE }}:v_${{ steps.vars.outputs.branch_name }}_${{ steps.vars.outputs.sha_short}}v
  #   steps:
  #     - name: Checkout Code
  #       uses: actions/checkout@master

  #     - name: Current Date
  #       id: current_date
  #       run: |
  #         echo "created=$(date -u +"%Y-%m-%d %H:%M:%S%z")" | tee -a "$GITHUB_OUTPUT"
  #       shell: bash

  #     - name: Set variables for later steps
  #       id: vars
  #       run: |
  #         echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
  #         echo "sha_full=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
  #         echo "branch_name=$(git rev-parse --abbrev-ref HEAD)" >> $GITHUB_OUTPUT

  #     - name: Login to GitHub Container Registry
  #       uses: docker/login-action@v2
  #       with:
  #         registry: ghcr.io
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}

  #     - name: Build and push Docker images
  #       uses: docker/build-push-action@v4
  #       with:
  #         context: .
  #         file: Dockerfile.go_cross_amd64_to_arm64
  #         push: true
  #         tags: ${{ env.IMAGE }}:v_${{ steps.vars.outputs.branch_name }}_${{ steps.vars.outputs.sha_short }}v
  #         labels: |
  #           org.opencontainers.image.title=kaskada go cross compilation image
  #           org.opencontainers.image.description=The kaskada go cross compilation image
  #           org.opencontainers.image.url=${{ github.repositoryUrl }}
  #           org.opencontainers.image.source=${{ github.repositoryUrl }}
  #           org.opencontainers.image.version=${{  steps.vars.outputs.sha_short }}
  #           org.opencontainers.image.created=${{ steps.current_date.outputs.created }}
  #           org.opencontainers.image.revision=${{ steps.vars.outputs.sha_full }}
  #           org.opencontainers.image.licenses=Apache-2.0

  #     - name: Output Docker Container Name
  #       id: docker-container-name
  #       run: |
  #         echo "${{ env.IMAGE }}:v_${{ steps.vars.outputs.branch_name }}_${{ steps.vars.outputs.sha_short}}v"

  # build_wren:
  #   needs: [build_cross_docker_image]
  #   runs-on: ubuntu-20.04
  #   ## Deviation: all steps are curried inside our docker image created from `build_cross_docker_image`
  #   container:
  #     image: ${{ needs.build_cross_docker_image.outputs.image-name }}
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@master

  #     - name: Wren - Install Buf
  #       uses: bufbuild/buf-setup-action@v1.12.0
  #       with:
  #         version: "1.10.0"
  #         buf_user: ${{ secrets.BUF_USER }}
  #         buf_api_token: ${{ secrets.BUF_API_TOKEN }}
  #         github_token: ${{ secrets.GITHUB_TOKEN }}

  #     - name: Wren - Generate Protobufs
  #       run: buf generate
  #       working-directory: proto

  #     ## Deviation: No Go install action here! Docker image has Go installed.
  #     - name: Wren - Generate Ent
  #       run: go generate ./ent
  #       working-directory: wren

  #     - name: Wren - Copy NOTICE
  #       run: cp NOTICE ./wren/

  #     ## Deviation: Grab the names for cross compiler and linker from inside the docker container
  #     - name: Set variables for cross compiler and linker
  #       id: vars
  #       run: |
  #         echo "cc=$(echo $CC_aarch64_unknown_linux_gnu)" >> $GITHUB_OUTPUT
  #         echo "cxx=$(echo $CXX_aarch64_unknown_linux_gnu)" >> $GITHUB_OUTPUT

  #     - name: Wren - Build
  #       run: |
  #         mkdir ../release/
  #         set
  #         go build -ldflags="-w -s" -o ../release/wren main.go
  #       working-directory: wren
  #       env:
  #         CGO_ENABLED: 1
  #         GOOS: linux
  #         GOARCH: arm64
  #         CC: ${{ steps.vars.outputs.cc }}
  #         CXX: ${{ steps.vars.outputs.cxx }}

  #     - name: Upload engine artifacts
  #       uses: actions/upload-artifact@v3
  #       with:
  #         name: engine-linux-aarch64
  #         retention-days: 5
  #         path: |
  #           release/wren

  #     - name: Add artifacts to release
  #       if: startsWith(github.ref, 'refs/tags/engine@v')
  #       run: |
  #         cp release/wren  ${WREN_ASSET_NAME}
  #         gh release upload ${TAG} ${WREN_ASSET_NAME} --clobber
  #       shell: bash
  #       env:
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #         TAG: ${{ github.ref_name }}
  #         # Name of the assets to produce. We don't include the version
  #         # so can have a stable link to the latest asset.
  #         WREN_ASSET_NAME: kaskada-manager-linux-aarch64

  # sparrow_cross_amd64_arm64:
  #   runs-on: ubuntu-20.04
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@master

  #     - name: Current Date
  #       id: current_date
  #       run: |
  #         echo "created=$(date -u +"%Y-%m-%d %H:%M:%S%z")" | tee -a "$GITHUB_OUTPUT"
  #       shell: bash

  #     - name: Rust install stable toolchain
  #       id: toolchain
  #       uses: dtolnay/rust-toolchain@master
  #       with:
  #         toolchain: stable
  #         components: clippy
  #         targets: aarch64-unknown-linux-gnu

  #     - name: Apt Packages (Linux)
  #       uses: awalsh128/cache-apt-pkgs-action@latest
  #       with:
  #         packages: lld
  #         version: 1.0

  #     - name: Install Protoc
  #       uses: Noelware/setup-protoc@1.0.2
  #       with:
  #         repo-token: ${{ secrets.GITHUB_TOKEN }}

  #     ## Deviation: Install cross crate
  #     - name: Cargo install cross crate
  #       shell: bash
  #       run: cargo install cross

  #     ## Deviation: build using `cross` command
  #     - name: Sparrow - cross build (Release)
  #       shell: bash
  #       run: |
  #         cross build --release --all-features --target aarch64-unknown-linux-gnu -p sparrow-main

  #     - name: Upload engine artifacts
  #       uses: actions/upload-artifact@v3
  #       with:
  #         name: engine-linux-aarch64
  #         retention-days: 5
  #         path: |
  #           target/aarch64-unknown-linux-gnu/release/sparrow-main

  #     - name: Add artifacts to release
  #       if: startsWith(github.ref, 'refs/tags/engine@v')
  #       run: |
  #         cp release/sparrow-main ${ENGINE_ASSET_NAME}
  #         gh release upload ${TAG} ${ENGINE_ASSET_NAME} --clobber
  #       shell: bash
  #       env:
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #         TAG: ${{ github.ref_name }}
  #         # Name of the assets to produce. We don't include the version
  #         # so can have a stable link to the latest asset.
  #         ENGINE_ASSET_NAME: kaskada-engine-linux-aarch64

  build_arm64_docker_image:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout sources
        uses: actions/checkout@v3

      - name: Set variables for later steps
        id: vars
        run: |
          echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "sha_full=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          echo "branch_name=$(git rev-parse --abbrev-ref HEAD)" >> $GITHUB_OUTPUT

        # Refs: https://www.stereolabs.com/docs/docker/building-arm-container-on-x86/
      - name: Install Ubuntu packages for muliplatform
        shell: bash
        run: |
          sudo apt-get install qemu binfmt-support qemu-user-static
          docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
          docker run --rm --platform linux/arm64 -t arm64v8/ubuntu uname -m
          mkdir -p releases

      # - name: Download artifacts for wren and sparrow
      #   uses: actions/download-artifact@v3
      #   with:
      #     name: engine-linux-aarch64
      #     path: releases/

      - name: REMOVE! Download binaries instead of building them to test workflow
        shell:bash 
        run: | 
          wget -O releases/sparrow --no-check-certificate 'https://drive.google.com/uc?export=download&id=1pw4Qm7L2rUQhJJt1jXvya26k7RW9ktlr'
          wget -O releases/wren --no-check-certificate 'https://drive.google.com/uc?export=download&id=1L5UMZlmWd6745rxM3FeUOQKLfiawyUc0'


      - name: Current Date
        id: current_date
        run: |
          echo "created=$(date -u +"%Y-%m-%d %H:%M:%S%z")" | tee -a "$GITHUB_OUTPUT"
        shell: bash

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        # if: ${{ startsWith(github.ref, 'refs/tags/engine@v') && matrix.target == 'x86_64-unknown-linux-gnu' }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        # if: ${{ startsWith(github.ref, 'refs/tags/engine@v') && matrix.target == 'x86_64-unknown-linux-gnu' }}
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker images
        uses: docker/build-push-action@v4
        # if: ${{ startsWith(github.ref, 'refs/tags/engine@v') && matrix.target == 'x86_64-unknown-linux-gnu' }}
        with:
          context: .
          platforms: linux/arm64
          file: Dockerfile.release
          push: true
          tags: ${{ env.PRE_RELEASE_IMAGE }}:${{ steps.vars.output.sha_short }},${{ env.PRE_RELEASE_IMAGE }}:latest
          labels: |
            org.opencontainers.image.title=kaskada engine linux/arm64
            org.opencontainers.image.description=The kaskada engine
            org.opencontainers.image.url=${{ github.repositoryUrl }}
            org.opencontainers.image.source=${{ github.repositoryUrl }}
            org.opencontainers.image.version=${{ steps.vars.output.sha_short }}
            org.opencontainers.image.created=${{ steps.current_date.outputs.created }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.licenses=Apache-2.0
