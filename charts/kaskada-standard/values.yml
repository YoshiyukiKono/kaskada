# Default values for kaskada.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

image:
  repository: ghcr.io/kaskada/kaskada
  # Overrides the image tag whose default is v{{ .Chart.AppVersion }}
  tag: ""
  pullPolicy: IfNotPresent

imagePullSecrets: []

nameOverride: ""
fullnameOverride: ""

# the object store where data will be stored.
# should be `s3`, `gcs`, or `azure`.  
objectStore: 
  s3:
    enabled:
    bucket:
  gcs:
    enabled:
    bucket:
  azure:
    enabled:
    container:

# the backing database, currently only postgres is supported
database:
  postgres:
    enabled: true
    db:
    host:
    port:
    pass: #recommend setting this via a secret or mutating webhook
    user:
    useSSL:


# labels to apply to all resources
commonLabels: {}



# these settings will be applied to both manager & compute pods
shared:
  affinity: {}
  podLabels: {}
  nodeSelector: {}
  podAnnotations: {}
  tolerations: []
  serviceAccount:
    # Specifies whether a shared service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # Labels to add to the service account
    labels: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

# these settings are only applied to compute pods
compute:
  affinity: {}
  podLabels: {}
  nodeSelector: {}
  podAnnotations: {}
  tolerations: []
  serviceAccount:
    # Specifies whether a compute-specific service account should be created
    # if this is `true`, the shared service account is not created
    create: false
    # Annotations to add to the service account
    annotations: {}
    # Labels to add to the service account
    labels: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""
  resources:
    limits:
      cpu: 4
      memory: 16Gi
    requests:
      cpu: 1
      memory: 8Gi
  replicas: 3

# these settings are only applied to manager pods
manager:
  affinity: {}
  podLabels: {}
  nodeSelector: {}
  podAnnotations: {}
  tolerations: []
  serviceAccount:
    # Specifies whether a manager-specific service account should be created
    # if this is `true`, the shared service account is not created
    create: false
    # Annotations to add to the service account
    annotations: {}
    # Labels to add to the service account
    labels: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""
  resources:
    limits:
      cpu: 500m
      memory: 500Mi
    requests:
      cpu: 100m
      memory: 250Mi
  replicas: 3

podSecurityContext:
  fsGroup: 65534

securityContext:
  runAsNonRoot: true
  runAsUser: 65534
  readOnlyRootFilesystem: true
  capabilities:
    drop: ["ALL"]

# Defaults to `ClusterFirst`.
# Valid values are: `ClusterFirstWithHostNet`, `ClusterFirst`, `Default` or `None`.
dnsPolicy:

priorityClassName: ""

terminationGracePeriodSeconds:


env: []

livenessProbe:
  httpGet:
    path: /healthz
    port: http
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 2
  successThreshold: 1

readinessProbe:
  httpGet:
    path: /healthz
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

service:
  grpcPort: 50051
  restPort: 8080
  annotations: {}

extraVolumes: []

extraVolumeMounts: []

resources: {}

tempVolume:

topologySpreadConstraints: []

logLevel: info
logFormat: json


extraArgs: []

secretConfiguration:
  enabled: false
  mountPath: ""
  subPath: ""
  data: {}
    # credentials: |
    #   [default]
    #   aws_access_key_id = $SECRET_ACCESS_KEY
    #   aws_secret_access_key = $SECRET_ACCESS_KEY

deploymentStrategy:
  type: Recreate
